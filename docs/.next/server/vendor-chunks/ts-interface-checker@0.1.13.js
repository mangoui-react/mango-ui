"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ts-interface-checker@0.1.13";
exports.ids = ["vendor-chunks/ts-interface-checker@0.1.13"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/index.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/index.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Checker = exports.createCheckers = void 0;\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/types.js\");\nvar util_1 = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/util.js\");\n/**\n * Export functions used to define interfaces.\n */\nvar types_2 = __webpack_require__(/*! ./types */ \"(ssr)/../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/types.js\");\nObject.defineProperty(exports, \"TArray\", ({ enumerable: true, get: function () { return types_2.TArray; } }));\nObject.defineProperty(exports, \"TEnumType\", ({ enumerable: true, get: function () { return types_2.TEnumType; } }));\nObject.defineProperty(exports, \"TEnumLiteral\", ({ enumerable: true, get: function () { return types_2.TEnumLiteral; } }));\nObject.defineProperty(exports, \"TFunc\", ({ enumerable: true, get: function () { return types_2.TFunc; } }));\nObject.defineProperty(exports, \"TIface\", ({ enumerable: true, get: function () { return types_2.TIface; } }));\nObject.defineProperty(exports, \"TLiteral\", ({ enumerable: true, get: function () { return types_2.TLiteral; } }));\nObject.defineProperty(exports, \"TName\", ({ enumerable: true, get: function () { return types_2.TName; } }));\nObject.defineProperty(exports, \"TOptional\", ({ enumerable: true, get: function () { return types_2.TOptional; } }));\nObject.defineProperty(exports, \"TParam\", ({ enumerable: true, get: function () { return types_2.TParam; } }));\nObject.defineProperty(exports, \"TParamList\", ({ enumerable: true, get: function () { return types_2.TParamList; } }));\nObject.defineProperty(exports, \"TProp\", ({ enumerable: true, get: function () { return types_2.TProp; } }));\nObject.defineProperty(exports, \"TTuple\", ({ enumerable: true, get: function () { return types_2.TTuple; } }));\nObject.defineProperty(exports, \"TType\", ({ enumerable: true, get: function () { return types_2.TType; } }));\nObject.defineProperty(exports, \"TUnion\", ({ enumerable: true, get: function () { return types_2.TUnion; } }));\nObject.defineProperty(exports, \"TIntersection\", ({ enumerable: true, get: function () { return types_2.TIntersection; } }));\nObject.defineProperty(exports, \"array\", ({ enumerable: true, get: function () { return types_2.array; } }));\nObject.defineProperty(exports, \"enumlit\", ({ enumerable: true, get: function () { return types_2.enumlit; } }));\nObject.defineProperty(exports, \"enumtype\", ({ enumerable: true, get: function () { return types_2.enumtype; } }));\nObject.defineProperty(exports, \"func\", ({ enumerable: true, get: function () { return types_2.func; } }));\nObject.defineProperty(exports, \"iface\", ({ enumerable: true, get: function () { return types_2.iface; } }));\nObject.defineProperty(exports, \"lit\", ({ enumerable: true, get: function () { return types_2.lit; } }));\nObject.defineProperty(exports, \"name\", ({ enumerable: true, get: function () { return types_2.name; } }));\nObject.defineProperty(exports, \"opt\", ({ enumerable: true, get: function () { return types_2.opt; } }));\nObject.defineProperty(exports, \"param\", ({ enumerable: true, get: function () { return types_2.param; } }));\nObject.defineProperty(exports, \"tuple\", ({ enumerable: true, get: function () { return types_2.tuple; } }));\nObject.defineProperty(exports, \"union\", ({ enumerable: true, get: function () { return types_2.union; } }));\nObject.defineProperty(exports, \"intersection\", ({ enumerable: true, get: function () { return types_2.intersection; } }));\nObject.defineProperty(exports, \"BasicType\", ({ enumerable: true, get: function () { return types_2.BasicType; } }));\nvar util_2 = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/util.js\");\nObject.defineProperty(exports, \"VError\", ({ enumerable: true, get: function () { return util_2.VError; } }));\n/**\n * Takes one of more type suites (e.g. a module generated by `ts-interface-builder`), and combines\n * them into a suite of interface checkers. If a type is used by name, that name should be present\n * among the passed-in type suites.\n *\n * The returned object maps type names to Checker objects.\n */\nfunction createCheckers() {\n    var typeSuite = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSuite[_i] = arguments[_i];\n    }\n    var fullSuite = Object.assign.apply(Object, __spreadArrays([{}, types_1.basicTypes], typeSuite));\n    var checkers = {};\n    for (var _a = 0, typeSuite_1 = typeSuite; _a < typeSuite_1.length; _a++) {\n        var suite_1 = typeSuite_1[_a];\n        for (var _b = 0, _c = Object.keys(suite_1); _b < _c.length; _b++) {\n            var name = _c[_b];\n            checkers[name] = new Checker(fullSuite, suite_1[name]);\n        }\n    }\n    return checkers;\n}\nexports.createCheckers = createCheckers;\n/**\n * Checker implements validation of objects, and also includes accessors to validate method calls.\n * Checkers should be created using `createCheckers()`.\n */\nvar Checker = /** @class */ (function () {\n    // Create checkers by using `createCheckers()` function.\n    function Checker(suite, ttype, _path) {\n        if (_path === void 0) { _path = 'value'; }\n        this.suite = suite;\n        this.ttype = ttype;\n        this._path = _path;\n        this.props = new Map();\n        if (ttype instanceof types_1.TIface) {\n            for (var _i = 0, _a = ttype.props; _i < _a.length; _i++) {\n                var p = _a[_i];\n                this.props.set(p.name, p.ttype);\n            }\n        }\n        this.checkerPlain = this.ttype.getChecker(suite, false);\n        this.checkerStrict = this.ttype.getChecker(suite, true);\n    }\n    /**\n     * Set the path to report in errors, instead of the default \"value\". (E.g. if the Checker is for\n     * a \"person\" interface, set path to \"person\" to report e.g. \"person.name is not a string\".)\n     */\n    Checker.prototype.setReportedPath = function (path) {\n        this._path = path;\n    };\n    /**\n     * Check that the given value satisfies this checker's type, or throw Error.\n     */\n    Checker.prototype.check = function (value) { return this._doCheck(this.checkerPlain, value); };\n    /**\n     * A fast check for whether or not the given value satisfies this Checker's type. This returns\n     * true or false, does not produce an error message, and is fast both on success and on failure.\n     */\n    Checker.prototype.test = function (value) {\n        return this.checkerPlain(value, new util_1.NoopContext());\n    };\n    /**\n     * Returns an error object describing the errors if the given value does not satisfy this\n     * Checker's type, or null if it does.\n     */\n    Checker.prototype.validate = function (value) {\n        return this._doValidate(this.checkerPlain, value);\n    };\n    /**\n     * Check that the given value satisfies this checker's type strictly. This checks that objects\n     * and tuples have no extra members. Note that this prevents backward compatibility, so usually\n     * a plain check() is more appropriate.\n     */\n    Checker.prototype.strictCheck = function (value) { return this._doCheck(this.checkerStrict, value); };\n    /**\n     * A fast strict check for whether or not the given value satisfies this Checker's type. Returns\n     * true or false, does not produce an error message, and is fast both on success and on failure.\n     */\n    Checker.prototype.strictTest = function (value) {\n        return this.checkerStrict(value, new util_1.NoopContext());\n    };\n    /**\n     * Returns an error object describing the errors if the given value does not satisfy this\n     * Checker's type strictly, or null if it does.\n     */\n    Checker.prototype.strictValidate = function (value) {\n        return this._doValidate(this.checkerStrict, value);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the type required for the given\n     * property of this interface.\n     */\n    Checker.prototype.getProp = function (prop) {\n        var ttype = this.props.get(prop);\n        if (!ttype) {\n            throw new Error(\"Type has no property \" + prop);\n        }\n        return new Checker(this.suite, ttype, this._path + \".\" + prop);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the argument-list required to call\n     * the given method of this interface. E.g. if this Checker is for the interface:\n     *    interface Foo {\n     *      find(s: string, pos?: number): number;\n     *    }\n     * Then methodArgs(\"find\").check(...) will succeed for [\"foo\"] and [\"foo\", 3], but not for [17].\n     */\n    Checker.prototype.methodArgs = function (methodName) {\n        var tfunc = this._getMethod(methodName);\n        return new Checker(this.suite, tfunc.paramList);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the return value of the given\n     * method of this interface.\n     */\n    Checker.prototype.methodResult = function (methodName) {\n        var tfunc = this._getMethod(methodName);\n        return new Checker(this.suite, tfunc.result);\n    };\n    /**\n     * If this checker is for a function, returns a Checker for its argument-list.\n     */\n    Checker.prototype.getArgs = function () {\n        if (!(this.ttype instanceof types_1.TFunc)) {\n            throw new Error(\"getArgs() applied to non-function\");\n        }\n        return new Checker(this.suite, this.ttype.paramList);\n    };\n    /**\n     * If this checker is for a function, returns a Checker for its result.\n     */\n    Checker.prototype.getResult = function () {\n        if (!(this.ttype instanceof types_1.TFunc)) {\n            throw new Error(\"getResult() applied to non-function\");\n        }\n        return new Checker(this.suite, this.ttype.result);\n    };\n    /**\n     * Return the type for which this is a checker.\n     */\n    Checker.prototype.getType = function () {\n        return this.ttype;\n    };\n    /**\n     * Actual implementation of check() and strictCheck().\n     */\n    Checker.prototype._doCheck = function (checkerFunc, value) {\n        var noopCtx = new util_1.NoopContext();\n        if (!checkerFunc(value, noopCtx)) {\n            var detailCtx = new util_1.DetailContext();\n            checkerFunc(value, detailCtx);\n            throw detailCtx.getError(this._path);\n        }\n    };\n    Checker.prototype._doValidate = function (checkerFunc, value) {\n        var noopCtx = new util_1.NoopContext();\n        if (checkerFunc(value, noopCtx)) {\n            return null;\n        }\n        var detailCtx = new util_1.DetailContext();\n        checkerFunc(value, detailCtx);\n        return detailCtx.getErrorDetail(this._path);\n    };\n    Checker.prototype._getMethod = function (methodName) {\n        var ttype = this.props.get(methodName);\n        if (!ttype) {\n            throw new Error(\"Type has no property \" + methodName);\n        }\n        if (!(ttype instanceof types_1.TFunc)) {\n            throw new Error(\"Property \" + methodName + \" is not a method\");\n        }\n        return ttype;\n    };\n    return Checker;\n}());\nexports.Checker = Checker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RzLWludGVyZmFjZS1jaGVja2VyQDAuMS4xMy9ub2RlX21vZHVsZXMvdHMtaW50ZXJmYWNlLWNoZWNrZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQseUNBQXlDLFFBQVE7QUFDakQseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxzQkFBc0I7QUFDeEMsY0FBYyxtQkFBTyxDQUFDLHdIQUFTO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxzSEFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsd0hBQVM7QUFDL0IsMENBQXlDLEVBQUUscUNBQXFDLDBCQUEwQixFQUFDO0FBQzNHLDZDQUE0QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUNqSCxnREFBK0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdkgseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLDBDQUF5QyxFQUFFLHFDQUFxQywwQkFBMEIsRUFBQztBQUMzRyw0Q0FBMkMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDL0cseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLDZDQUE0QyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUNqSCwwQ0FBeUMsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDM0csOENBQTZDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ25ILHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6RywwQ0FBeUMsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDM0cseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLDBDQUF5QyxFQUFFLHFDQUFxQywwQkFBMEIsRUFBQztBQUMzRyxpREFBZ0QsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDekgseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLDJDQUEwQyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM3Ryw0Q0FBMkMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDL0csd0NBQXVDLEVBQUUscUNBQXFDLHdCQUF3QixFQUFDO0FBQ3ZHLHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6Ryx1Q0FBc0MsRUFBRSxxQ0FBcUMsdUJBQXVCLEVBQUM7QUFDckcsd0NBQXVDLEVBQUUscUNBQXFDLHdCQUF3QixFQUFDO0FBQ3ZHLHVDQUFzQyxFQUFFLHFDQUFxQyx1QkFBdUIsRUFBQztBQUNyRyx5Q0FBd0MsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDekcseUNBQXdDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3pHLHlDQUF3QyxFQUFFLHFDQUFxQyx5QkFBeUIsRUFBQztBQUN6RyxnREFBK0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdkgsNkNBQTRDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ2pILGFBQWEsbUJBQU8sQ0FBQyxzSEFBUTtBQUM3QiwwQ0FBeUMsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2RvY3MvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RzLWludGVyZmFjZS1jaGVja2VyQDAuMS4xMy9ub2RlX21vZHVsZXMvdHMtaW50ZXJmYWNlLWNoZWNrZXIvZGlzdC9pbmRleC5qcz9jNWI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoZWNrZXIgPSBleHBvcnRzLmNyZWF0ZUNoZWNrZXJzID0gdm9pZCAwO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuLyoqXG4gKiBFeHBvcnQgZnVuY3Rpb25zIHVzZWQgdG8gZGVmaW5lIGludGVyZmFjZXMuXG4gKi9cbnZhciB0eXBlc18yID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUQXJyYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIuVEFycmF5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVEVudW1UeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRFbnVtVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRFbnVtTGl0ZXJhbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5URW51bUxpdGVyYWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJURnVuY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5URnVuYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRJZmFjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5USWZhY2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUTGl0ZXJhbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5UTGl0ZXJhbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlROYW1lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlROYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVE9wdGlvbmFsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRPcHRpb25hbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRQYXJhbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5UUGFyYW07IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUUGFyYW1MaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRQYXJhbUxpc3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUUHJvcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5UUHJvcDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRUdXBsZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5UVHVwbGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5UVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRVbmlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5UVW5pb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUSW50ZXJzZWN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLlRJbnRlcnNlY3Rpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhcnJheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5hcnJheTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVudW1saXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIuZW51bWxpdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVudW10eXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLmVudW10eXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZnVuY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5mdW5jOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaWZhY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIuaWZhY2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsaXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIubGl0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5uYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwib3B0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLm9wdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcmFtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18yLnBhcmFtOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidHVwbGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIudHVwbGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1bmlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi51bmlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImludGVyc2VjdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMi5pbnRlcnNlY3Rpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNpY1R5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzIuQmFzaWNUeXBlOyB9IH0pO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxfMi5WRXJyb3I7IH0gfSk7XG4vKipcbiAqIFRha2VzIG9uZSBvZiBtb3JlIHR5cGUgc3VpdGVzIChlLmcuIGEgbW9kdWxlIGdlbmVyYXRlZCBieSBgdHMtaW50ZXJmYWNlLWJ1aWxkZXJgKSwgYW5kIGNvbWJpbmVzXG4gKiB0aGVtIGludG8gYSBzdWl0ZSBvZiBpbnRlcmZhY2UgY2hlY2tlcnMuIElmIGEgdHlwZSBpcyB1c2VkIGJ5IG5hbWUsIHRoYXQgbmFtZSBzaG91bGQgYmUgcHJlc2VudFxuICogYW1vbmcgdGhlIHBhc3NlZC1pbiB0eXBlIHN1aXRlcy5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgb2JqZWN0IG1hcHMgdHlwZSBuYW1lcyB0byBDaGVja2VyIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoZWNrZXJzKCkge1xuICAgIHZhciB0eXBlU3VpdGUgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0eXBlU3VpdGVbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGZ1bGxTdWl0ZSA9IE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBfX3NwcmVhZEFycmF5cyhbe30sIHR5cGVzXzEuYmFzaWNUeXBlc10sIHR5cGVTdWl0ZSkpO1xuICAgIHZhciBjaGVja2VycyA9IHt9O1xuICAgIGZvciAodmFyIF9hID0gMCwgdHlwZVN1aXRlXzEgPSB0eXBlU3VpdGU7IF9hIDwgdHlwZVN1aXRlXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgIHZhciBzdWl0ZV8xID0gdHlwZVN1aXRlXzFbX2FdO1xuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gT2JqZWN0LmtleXMoc3VpdGVfMSk7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9jW19iXTtcbiAgICAgICAgICAgIGNoZWNrZXJzW25hbWVdID0gbmV3IENoZWNrZXIoZnVsbFN1aXRlLCBzdWl0ZV8xW25hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hlY2tlcnM7XG59XG5leHBvcnRzLmNyZWF0ZUNoZWNrZXJzID0gY3JlYXRlQ2hlY2tlcnM7XG4vKipcbiAqIENoZWNrZXIgaW1wbGVtZW50cyB2YWxpZGF0aW9uIG9mIG9iamVjdHMsIGFuZCBhbHNvIGluY2x1ZGVzIGFjY2Vzc29ycyB0byB2YWxpZGF0ZSBtZXRob2QgY2FsbHMuXG4gKiBDaGVja2VycyBzaG91bGQgYmUgY3JlYXRlZCB1c2luZyBgY3JlYXRlQ2hlY2tlcnMoKWAuXG4gKi9cbnZhciBDaGVja2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIENyZWF0ZSBjaGVja2VycyBieSB1c2luZyBgY3JlYXRlQ2hlY2tlcnMoKWAgZnVuY3Rpb24uXG4gICAgZnVuY3Rpb24gQ2hlY2tlcihzdWl0ZSwgdHR5cGUsIF9wYXRoKSB7XG4gICAgICAgIGlmIChfcGF0aCA9PT0gdm9pZCAwKSB7IF9wYXRoID0gJ3ZhbHVlJzsgfVxuICAgICAgICB0aGlzLnN1aXRlID0gc3VpdGU7XG4gICAgICAgIHRoaXMudHR5cGUgPSB0dHlwZTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xuICAgICAgICB0aGlzLnByb3BzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAodHR5cGUgaW5zdGFuY2VvZiB0eXBlc18xLlRJZmFjZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHR0eXBlLnByb3BzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuc2V0KHAubmFtZSwgcC50dHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja2VyUGxhaW4gPSB0aGlzLnR0eXBlLmdldENoZWNrZXIoc3VpdGUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jaGVja2VyU3RyaWN0ID0gdGhpcy50dHlwZS5nZXRDaGVja2VyKHN1aXRlLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwYXRoIHRvIHJlcG9ydCBpbiBlcnJvcnMsIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgXCJ2YWx1ZVwiLiAoRS5nLiBpZiB0aGUgQ2hlY2tlciBpcyBmb3JcbiAgICAgKiBhIFwicGVyc29uXCIgaW50ZXJmYWNlLCBzZXQgcGF0aCB0byBcInBlcnNvblwiIHRvIHJlcG9ydCBlLmcuIFwicGVyc29uLm5hbWUgaXMgbm90IGEgc3RyaW5nXCIuKVxuICAgICAqL1xuICAgIENoZWNrZXIucHJvdG90eXBlLnNldFJlcG9ydGVkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIHRoaXMgY2hlY2tlcidzIHR5cGUsIG9yIHRocm93IEVycm9yLlxuICAgICAqL1xuICAgIENoZWNrZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9kb0NoZWNrKHRoaXMuY2hlY2tlclBsYWluLCB2YWx1ZSk7IH07XG4gICAgLyoqXG4gICAgICogQSBmYXN0IGNoZWNrIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIHRoaXMgQ2hlY2tlcidzIHR5cGUuIFRoaXMgcmV0dXJuc1xuICAgICAqIHRydWUgb3IgZmFsc2UsIGRvZXMgbm90IHByb2R1Y2UgYW4gZXJyb3IgbWVzc2FnZSwgYW5kIGlzIGZhc3QgYm90aCBvbiBzdWNjZXNzIGFuZCBvbiBmYWlsdXJlLlxuICAgICAqL1xuICAgIENoZWNrZXIucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tlclBsYWluKHZhbHVlLCBuZXcgdXRpbF8xLk5vb3BDb250ZXh0KCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlcnJvciBvYmplY3QgZGVzY3JpYmluZyB0aGUgZXJyb3JzIGlmIHRoZSBnaXZlbiB2YWx1ZSBkb2VzIG5vdCBzYXRpc2Z5IHRoaXNcbiAgICAgKiBDaGVja2VyJ3MgdHlwZSwgb3IgbnVsbCBpZiBpdCBkb2VzLlxuICAgICAqL1xuICAgIENoZWNrZXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb1ZhbGlkYXRlKHRoaXMuY2hlY2tlclBsYWluLCB2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgdGhpcyBjaGVja2VyJ3MgdHlwZSBzdHJpY3RseS4gVGhpcyBjaGVja3MgdGhhdCBvYmplY3RzXG4gICAgICogYW5kIHR1cGxlcyBoYXZlIG5vIGV4dHJhIG1lbWJlcnMuIE5vdGUgdGhhdCB0aGlzIHByZXZlbnRzIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHNvIHVzdWFsbHlcbiAgICAgKiBhIHBsYWluIGNoZWNrKCkgaXMgbW9yZSBhcHByb3ByaWF0ZS5cbiAgICAgKi9cbiAgICBDaGVja2VyLnByb3RvdHlwZS5zdHJpY3RDaGVjayA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fZG9DaGVjayh0aGlzLmNoZWNrZXJTdHJpY3QsIHZhbHVlKTsgfTtcbiAgICAvKipcbiAgICAgKiBBIGZhc3Qgc3RyaWN0IGNoZWNrIGZvciB3aGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIHRoaXMgQ2hlY2tlcidzIHR5cGUuIFJldHVybnNcbiAgICAgKiB0cnVlIG9yIGZhbHNlLCBkb2VzIG5vdCBwcm9kdWNlIGFuIGVycm9yIG1lc3NhZ2UsIGFuZCBpcyBmYXN0IGJvdGggb24gc3VjY2VzcyBhbmQgb24gZmFpbHVyZS5cbiAgICAgKi9cbiAgICBDaGVja2VyLnByb3RvdHlwZS5zdHJpY3RUZXN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrZXJTdHJpY3QodmFsdWUsIG5ldyB1dGlsXzEuTm9vcENvbnRleHQoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVycm9yIG9iamVjdCBkZXNjcmliaW5nIHRoZSBlcnJvcnMgaWYgdGhlIGdpdmVuIHZhbHVlIGRvZXMgbm90IHNhdGlzZnkgdGhpc1xuICAgICAqIENoZWNrZXIncyB0eXBlIHN0cmljdGx5LCBvciBudWxsIGlmIGl0IGRvZXMuXG4gICAgICovXG4gICAgQ2hlY2tlci5wcm90b3R5cGUuc3RyaWN0VmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvVmFsaWRhdGUodGhpcy5jaGVja2VyU3RyaWN0LCB2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGNoZWNrZXIgaXMgZm9yIGFuIGludGVyZmFjZSwgcmV0dXJucyBhIENoZWNrZXIgZm9yIHRoZSB0eXBlIHJlcXVpcmVkIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiBwcm9wZXJ0eSBvZiB0aGlzIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBDaGVja2VyLnByb3RvdHlwZS5nZXRQcm9wID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgdmFyIHR0eXBlID0gdGhpcy5wcm9wcy5nZXQocHJvcCk7XG4gICAgICAgIGlmICghdHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgaGFzIG5vIHByb3BlcnR5IFwiICsgcHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGVja2VyKHRoaXMuc3VpdGUsIHR0eXBlLCB0aGlzLl9wYXRoICsgXCIuXCIgKyBwcm9wKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgY2hlY2tlciBpcyBmb3IgYW4gaW50ZXJmYWNlLCByZXR1cm5zIGEgQ2hlY2tlciBmb3IgdGhlIGFyZ3VtZW50LWxpc3QgcmVxdWlyZWQgdG8gY2FsbFxuICAgICAqIHRoZSBnaXZlbiBtZXRob2Qgb2YgdGhpcyBpbnRlcmZhY2UuIEUuZy4gaWYgdGhpcyBDaGVja2VyIGlzIGZvciB0aGUgaW50ZXJmYWNlOlxuICAgICAqICAgIGludGVyZmFjZSBGb28ge1xuICAgICAqICAgICAgZmluZChzOiBzdHJpbmcsIHBvcz86IG51bWJlcik6IG51bWJlcjtcbiAgICAgKiAgICB9XG4gICAgICogVGhlbiBtZXRob2RBcmdzKFwiZmluZFwiKS5jaGVjayguLi4pIHdpbGwgc3VjY2VlZCBmb3IgW1wiZm9vXCJdIGFuZCBbXCJmb29cIiwgM10sIGJ1dCBub3QgZm9yIFsxN10uXG4gICAgICovXG4gICAgQ2hlY2tlci5wcm90b3R5cGUubWV0aG9kQXJncyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciB0ZnVuYyA9IHRoaXMuX2dldE1ldGhvZChtZXRob2ROYW1lKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGVja2VyKHRoaXMuc3VpdGUsIHRmdW5jLnBhcmFtTGlzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGNoZWNrZXIgaXMgZm9yIGFuIGludGVyZmFjZSwgcmV0dXJucyBhIENoZWNrZXIgZm9yIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGdpdmVuXG4gICAgICogbWV0aG9kIG9mIHRoaXMgaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIENoZWNrZXIucHJvdG90eXBlLm1ldGhvZFJlc3VsdCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciB0ZnVuYyA9IHRoaXMuX2dldE1ldGhvZChtZXRob2ROYW1lKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGVja2VyKHRoaXMuc3VpdGUsIHRmdW5jLnJlc3VsdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGNoZWNrZXIgaXMgZm9yIGEgZnVuY3Rpb24sIHJldHVybnMgYSBDaGVja2VyIGZvciBpdHMgYXJndW1lbnQtbGlzdC5cbiAgICAgKi9cbiAgICBDaGVja2VyLnByb3RvdHlwZS5nZXRBcmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoISh0aGlzLnR0eXBlIGluc3RhbmNlb2YgdHlwZXNfMS5URnVuYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldEFyZ3MoKSBhcHBsaWVkIHRvIG5vbi1mdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoZWNrZXIodGhpcy5zdWl0ZSwgdGhpcy50dHlwZS5wYXJhbUxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBjaGVja2VyIGlzIGZvciBhIGZ1bmN0aW9uLCByZXR1cm5zIGEgQ2hlY2tlciBmb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBDaGVja2VyLnByb3RvdHlwZS5nZXRSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghKHRoaXMudHR5cGUgaW5zdGFuY2VvZiB0eXBlc18xLlRGdW5jKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0UmVzdWx0KCkgYXBwbGllZCB0byBub24tZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGVja2VyKHRoaXMuc3VpdGUsIHRoaXMudHR5cGUucmVzdWx0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdHlwZSBmb3Igd2hpY2ggdGhpcyBpcyBhIGNoZWNrZXIuXG4gICAgICovXG4gICAgQ2hlY2tlci5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHR5cGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBY3R1YWwgaW1wbGVtZW50YXRpb24gb2YgY2hlY2soKSBhbmQgc3RyaWN0Q2hlY2soKS5cbiAgICAgKi9cbiAgICBDaGVja2VyLnByb3RvdHlwZS5fZG9DaGVjayA9IGZ1bmN0aW9uIChjaGVja2VyRnVuYywgdmFsdWUpIHtcbiAgICAgICAgdmFyIG5vb3BDdHggPSBuZXcgdXRpbF8xLk5vb3BDb250ZXh0KCk7XG4gICAgICAgIGlmICghY2hlY2tlckZ1bmModmFsdWUsIG5vb3BDdHgpKSB7XG4gICAgICAgICAgICB2YXIgZGV0YWlsQ3R4ID0gbmV3IHV0aWxfMS5EZXRhaWxDb250ZXh0KCk7XG4gICAgICAgICAgICBjaGVja2VyRnVuYyh2YWx1ZSwgZGV0YWlsQ3R4KTtcbiAgICAgICAgICAgIHRocm93IGRldGFpbEN0eC5nZXRFcnJvcih0aGlzLl9wYXRoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2hlY2tlci5wcm90b3R5cGUuX2RvVmFsaWRhdGUgPSBmdW5jdGlvbiAoY2hlY2tlckZ1bmMsIHZhbHVlKSB7XG4gICAgICAgIHZhciBub29wQ3R4ID0gbmV3IHV0aWxfMS5Ob29wQ29udGV4dCgpO1xuICAgICAgICBpZiAoY2hlY2tlckZ1bmModmFsdWUsIG5vb3BDdHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGV0YWlsQ3R4ID0gbmV3IHV0aWxfMS5EZXRhaWxDb250ZXh0KCk7XG4gICAgICAgIGNoZWNrZXJGdW5jKHZhbHVlLCBkZXRhaWxDdHgpO1xuICAgICAgICByZXR1cm4gZGV0YWlsQ3R4LmdldEVycm9yRGV0YWlsKHRoaXMuX3BhdGgpO1xuICAgIH07XG4gICAgQ2hlY2tlci5wcm90b3R5cGUuX2dldE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciB0dHlwZSA9IHRoaXMucHJvcHMuZ2V0KG1ldGhvZE5hbWUpO1xuICAgICAgICBpZiAoIXR0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIGhhcyBubyBwcm9wZXJ0eSBcIiArIG1ldGhvZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHR0eXBlIGluc3RhbmNlb2YgdHlwZXNfMS5URnVuYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3BlcnR5IFwiICsgbWV0aG9kTmFtZSArIFwiIGlzIG5vdCBhIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHR5cGU7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hlY2tlcjtcbn0oKSk7XG5leHBvcnRzLkNoZWNrZXIgPSBDaGVja2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/types.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/types.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * This module defines nodes used to define types and validations for objects and interfaces.\n */\n// tslint:disable:no-shadowed-variable prefer-for-of\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;\nvar util_1 = __webpack_require__(/*! ./util */ \"(ssr)/../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/util.js\");\n/** Node that represents a type. */\nvar TType = /** @class */ (function () {\n    function TType() {\n    }\n    return TType;\n}());\nexports.TType = TType;\n/** Parses a type spec into a TType node. */\nfunction parseSpec(typeSpec) {\n    return typeof typeSpec === \"string\" ? name(typeSpec) : typeSpec;\n}\nfunction getNamedType(suite, name) {\n    var ttype = suite[name];\n    if (!ttype) {\n        throw new Error(\"Unknown type \" + name);\n    }\n    return ttype;\n}\n/**\n * Defines a type name, either built-in, or defined in this suite. It can typically be included in\n * the specs as just a plain string.\n */\nfunction name(value) { return new TName(value); }\nexports.name = name;\nvar TName = /** @class */ (function (_super) {\n    __extends(TName, _super);\n    function TName(name) {\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        _this._failMsg = \"is not a \" + name;\n        return _this;\n    }\n    TName.prototype.getChecker = function (suite, strict, allowedProps) {\n        var _this = this;\n        var ttype = getNamedType(suite, this.name);\n        var checker = ttype.getChecker(suite, strict, allowedProps);\n        if (ttype instanceof BasicType || ttype instanceof TName) {\n            return checker;\n        }\n        // For complex types, add an additional \"is not a <Type>\" message on failure.\n        return function (value, ctx) { return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0); };\n    };\n    return TName;\n}(TType));\nexports.TName = TName;\n/**\n * Defines a literal value, e.g. lit('hello') or lit(123).\n */\nfunction lit(value) { return new TLiteral(value); }\nexports.lit = lit;\nvar TLiteral = /** @class */ (function (_super) {\n    __extends(TLiteral, _super);\n    function TLiteral(value) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        _this.name = JSON.stringify(value);\n        _this._failMsg = \"is not \" + _this.name;\n        return _this;\n    }\n    TLiteral.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) { return (value === _this.value) ? true : ctx.fail(null, _this._failMsg, -1); };\n    };\n    return TLiteral;\n}(TType));\nexports.TLiteral = TLiteral;\n/**\n * Defines an array type, e.g. array('number').\n */\nfunction array(typeSpec) { return new TArray(parseSpec(typeSpec)); }\nexports.array = array;\nvar TArray = /** @class */ (function (_super) {\n    __extends(TArray, _super);\n    function TArray(ttype) {\n        var _this = _super.call(this) || this;\n        _this.ttype = ttype;\n        return _this;\n    }\n    TArray.prototype.getChecker = function (suite, strict) {\n        var itemChecker = this.ttype.getChecker(suite, strict);\n        return function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < value.length; i++) {\n                var ok = itemChecker(value[i], ctx);\n                if (!ok) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n    };\n    return TArray;\n}(TType));\nexports.TArray = TArray;\n/**\n * Defines a tuple type, e.g. tuple('string', 'number').\n */\nfunction tuple() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TTuple(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.tuple = tuple;\nvar TTuple = /** @class */ (function (_super) {\n    __extends(TTuple, _super);\n    function TTuple(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        return _this;\n    }\n    TTuple.prototype.getChecker = function (suite, strict) {\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });\n        var checker = function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var ok = itemCheckers[i](value[i], ctx);\n                if (!ok) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            return value.length <= itemCheckers.length ? true :\n                ctx.fail(itemCheckers.length, \"is extraneous\", 2);\n        };\n    };\n    return TTuple;\n}(TType));\nexports.TTuple = TTuple;\n/**\n * Defines a union type, e.g. union('number', 'null').\n */\nfunction union() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TUnion(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.union = union;\nvar TUnion = /** @class */ (function (_super) {\n    __extends(TUnion, _super);\n    function TUnion(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        var names = ttypes.map(function (t) { return t instanceof TName || t instanceof TLiteral ? t.name : null; })\n            .filter(function (n) { return n; });\n        var otherTypes = ttypes.length - names.length;\n        if (names.length) {\n            if (otherTypes > 0) {\n                names.push(otherTypes + \" more\");\n            }\n            _this._failMsg = \"is none of \" + names.join(\", \");\n        }\n        else {\n            _this._failMsg = \"is none of \" + otherTypes + \" types\";\n        }\n        return _this;\n    }\n    TUnion.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });\n        return function (value, ctx) {\n            var ur = ctx.unionResolver();\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var ok = itemCheckers[i](value, ur.createContext());\n                if (ok) {\n                    return true;\n                }\n            }\n            ctx.resolveUnion(ur);\n            return ctx.fail(null, _this._failMsg, 0);\n        };\n    };\n    return TUnion;\n}(TType));\nexports.TUnion = TUnion;\n/**\n * Defines an intersection type, e.g. intersection('number', 'null').\n */\nfunction intersection() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TIntersection(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.intersection = intersection;\nvar TIntersection = /** @class */ (function (_super) {\n    __extends(TIntersection, _super);\n    function TIntersection(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        return _this;\n    }\n    TIntersection.prototype.getChecker = function (suite, strict) {\n        var allowedProps = new Set();\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict, allowedProps); });\n        return function (value, ctx) {\n            var ok = itemCheckers.every(function (checker) { return checker(value, ctx); });\n            if (ok) {\n                return true;\n            }\n            return ctx.fail(null, null, 0);\n        };\n    };\n    return TIntersection;\n}(TType));\nexports.TIntersection = TIntersection;\n/**\n * Defines an enum type, e.g. enum({'A': 1, 'B': 2}).\n */\nfunction enumtype(values) {\n    return new TEnumType(values);\n}\nexports.enumtype = enumtype;\nvar TEnumType = /** @class */ (function (_super) {\n    __extends(TEnumType, _super);\n    function TEnumType(members) {\n        var _this = _super.call(this) || this;\n        _this.members = members;\n        _this.validValues = new Set();\n        _this._failMsg = \"is not a valid enum value\";\n        _this.validValues = new Set(Object.keys(members).map(function (name) { return members[name]; }));\n        return _this;\n    }\n    TEnumType.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) {\n            return (_this.validValues.has(value) ? true : ctx.fail(null, _this._failMsg, 0));\n        };\n    };\n    return TEnumType;\n}(TType));\nexports.TEnumType = TEnumType;\n/**\n * Defines a literal enum value, such as Direction.Up, specified as enumlit(\"Direction\", \"Up\").\n */\nfunction enumlit(name, prop) {\n    return new TEnumLiteral(name, prop);\n}\nexports.enumlit = enumlit;\nvar TEnumLiteral = /** @class */ (function (_super) {\n    __extends(TEnumLiteral, _super);\n    function TEnumLiteral(enumName, prop) {\n        var _this = _super.call(this) || this;\n        _this.enumName = enumName;\n        _this.prop = prop;\n        _this._failMsg = \"is not \" + enumName + \".\" + prop;\n        return _this;\n    }\n    TEnumLiteral.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var ttype = getNamedType(suite, this.enumName);\n        if (!(ttype instanceof TEnumType)) {\n            throw new Error(\"Type \" + this.enumName + \" used in enumlit is not an enum type\");\n        }\n        var val = ttype.members[this.prop];\n        if (!ttype.members.hasOwnProperty(this.prop)) {\n            throw new Error(\"Unknown value \" + this.enumName + \".\" + this.prop + \" used in enumlit\");\n        }\n        return function (value, ctx) { return (value === val) ? true : ctx.fail(null, _this._failMsg, -1); };\n    };\n    return TEnumLiteral;\n}(TType));\nexports.TEnumLiteral = TEnumLiteral;\nfunction makeIfaceProps(props) {\n    return Object.keys(props).map(function (name) { return makeIfaceProp(name, props[name]); });\n}\nfunction makeIfaceProp(name, prop) {\n    return prop instanceof TOptional ?\n        new TProp(name, prop.ttype, true) :\n        new TProp(name, parseSpec(prop), false);\n}\n/**\n * Defines an interface. The first argument is an array of interfaces that it extends, and the\n * second is an array of properties.\n */\nfunction iface(bases, props) {\n    return new TIface(bases, makeIfaceProps(props));\n}\nexports.iface = iface;\nvar TIface = /** @class */ (function (_super) {\n    __extends(TIface, _super);\n    function TIface(bases, props) {\n        var _this = _super.call(this) || this;\n        _this.bases = bases;\n        _this.props = props;\n        _this.propSet = new Set(props.map(function (p) { return p.name; }));\n        return _this;\n    }\n    TIface.prototype.getChecker = function (suite, strict, allowedProps) {\n        var _this = this;\n        var baseCheckers = this.bases.map(function (b) { return getNamedType(suite, b).getChecker(suite, strict); });\n        var propCheckers = this.props.map(function (prop) { return prop.ttype.getChecker(suite, strict); });\n        var testCtx = new util_1.NoopContext();\n        // Consider a prop required if it's not optional AND does not allow for undefined as a value.\n        var isPropRequired = this.props.map(function (prop, i) {\n            return !prop.isOpt && !propCheckers[i](undefined, testCtx);\n        });\n        var checker = function (value, ctx) {\n            if (typeof value !== \"object\" || value === null) {\n                return ctx.fail(null, \"is not an object\", 0);\n            }\n            for (var i = 0; i < baseCheckers.length; i++) {\n                if (!baseCheckers[i](value, ctx)) {\n                    return false;\n                }\n            }\n            for (var i = 0; i < propCheckers.length; i++) {\n                var name_1 = _this.props[i].name;\n                var v = value[name_1];\n                if (v === undefined) {\n                    if (isPropRequired[i]) {\n                        return ctx.fail(name_1, \"is missing\", 1);\n                    }\n                }\n                else {\n                    var ok = propCheckers[i](v, ctx);\n                    if (!ok) {\n                        return ctx.fail(name_1, null, 1);\n                    }\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        var propSet = this.propSet;\n        if (allowedProps) {\n            this.propSet.forEach(function (prop) { return allowedProps.add(prop); });\n            propSet = allowedProps;\n        }\n        // In strict mode, check also for unknown enumerable properties.\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            for (var prop in value) {\n                if (!propSet.has(prop)) {\n                    return ctx.fail(prop, \"is extraneous\", 2);\n                }\n            }\n            return true;\n        };\n    };\n    return TIface;\n}(TType));\nexports.TIface = TIface;\n/**\n * Defines an optional property on an interface.\n */\nfunction opt(typeSpec) { return new TOptional(parseSpec(typeSpec)); }\nexports.opt = opt;\nvar TOptional = /** @class */ (function (_super) {\n    __extends(TOptional, _super);\n    function TOptional(ttype) {\n        var _this = _super.call(this) || this;\n        _this.ttype = ttype;\n        return _this;\n    }\n    TOptional.prototype.getChecker = function (suite, strict) {\n        var itemChecker = this.ttype.getChecker(suite, strict);\n        return function (value, ctx) {\n            return value === undefined || itemChecker(value, ctx);\n        };\n    };\n    return TOptional;\n}(TType));\nexports.TOptional = TOptional;\n/**\n * Defines a property in an interface.\n */\nvar TProp = /** @class */ (function () {\n    function TProp(name, ttype, isOpt) {\n        this.name = name;\n        this.ttype = ttype;\n        this.isOpt = isOpt;\n    }\n    return TProp;\n}());\nexports.TProp = TProp;\n/**\n * Defines a function. The first argument declares the function's return type, the rest declare\n * its parameters.\n */\nfunction func(resultSpec) {\n    var params = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        params[_i - 1] = arguments[_i];\n    }\n    return new TFunc(new TParamList(params), parseSpec(resultSpec));\n}\nexports.func = func;\nvar TFunc = /** @class */ (function (_super) {\n    __extends(TFunc, _super);\n    function TFunc(paramList, result) {\n        var _this = _super.call(this) || this;\n        _this.paramList = paramList;\n        _this.result = result;\n        return _this;\n    }\n    TFunc.prototype.getChecker = function (suite, strict) {\n        return function (value, ctx) {\n            return typeof value === \"function\" ? true : ctx.fail(null, \"is not a function\", 0);\n        };\n    };\n    return TFunc;\n}(TType));\nexports.TFunc = TFunc;\n/**\n * Defines a function parameter.\n */\nfunction param(name, typeSpec, isOpt) {\n    return new TParam(name, parseSpec(typeSpec), Boolean(isOpt));\n}\nexports.param = param;\nvar TParam = /** @class */ (function () {\n    function TParam(name, ttype, isOpt) {\n        this.name = name;\n        this.ttype = ttype;\n        this.isOpt = isOpt;\n    }\n    return TParam;\n}());\nexports.TParam = TParam;\n/**\n * Defines a function parameter list.\n */\nvar TParamList = /** @class */ (function (_super) {\n    __extends(TParamList, _super);\n    function TParamList(params) {\n        var _this = _super.call(this) || this;\n        _this.params = params;\n        return _this;\n    }\n    TParamList.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var itemCheckers = this.params.map(function (t) { return t.ttype.getChecker(suite, strict); });\n        var testCtx = new util_1.NoopContext();\n        var isParamRequired = this.params.map(function (param, i) {\n            return !param.isOpt && !itemCheckers[i](undefined, testCtx);\n        });\n        var checker = function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var p = _this.params[i];\n                if (value[i] === undefined) {\n                    if (isParamRequired[i]) {\n                        return ctx.fail(p.name, \"is missing\", 1);\n                    }\n                }\n                else {\n                    var ok = itemCheckers[i](value[i], ctx);\n                    if (!ok) {\n                        return ctx.fail(p.name, null, 1);\n                    }\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            return value.length <= itemCheckers.length ? true :\n                ctx.fail(itemCheckers.length, \"is extraneous\", 2);\n        };\n    };\n    return TParamList;\n}(TType));\nexports.TParamList = TParamList;\n/**\n * Single TType implementation for all basic built-in types.\n */\nvar BasicType = /** @class */ (function (_super) {\n    __extends(BasicType, _super);\n    function BasicType(validator, message) {\n        var _this = _super.call(this) || this;\n        _this.validator = validator;\n        _this.message = message;\n        return _this;\n    }\n    BasicType.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) { return _this.validator(value) ? true : ctx.fail(null, _this.message, 0); };\n    };\n    return BasicType;\n}(TType));\nexports.BasicType = BasicType;\n/**\n * Defines the suite of basic types.\n */\nexports.basicTypes = {\n    any: new BasicType(function (v) { return true; }, \"is invalid\"),\n    number: new BasicType(function (v) { return (typeof v === \"number\"); }, \"is not a number\"),\n    object: new BasicType(function (v) { return (typeof v === \"object\" && v); }, \"is not an object\"),\n    boolean: new BasicType(function (v) { return (typeof v === \"boolean\"); }, \"is not a boolean\"),\n    string: new BasicType(function (v) { return (typeof v === \"string\"); }, \"is not a string\"),\n    symbol: new BasicType(function (v) { return (typeof v === \"symbol\"); }, \"is not a symbol\"),\n    void: new BasicType(function (v) { return (v == null); }, \"is not void\"),\n    undefined: new BasicType(function (v) { return (v === undefined); }, \"is not undefined\"),\n    null: new BasicType(function (v) { return (v === null); }, \"is not null\"),\n    never: new BasicType(function (v) { return false; }, \"is unexpected\"),\n    Date: new BasicType(getIsNativeChecker(\"[object Date]\"), \"is not a Date\"),\n    RegExp: new BasicType(getIsNativeChecker(\"[object RegExp]\"), \"is not a RegExp\"),\n};\n// This approach for checking native object types mirrors that of lodash. Its advantage over\n// `isinstance` is that it can still return true for native objects created in different JS\n// execution environments.\nvar nativeToString = Object.prototype.toString;\nfunction getIsNativeChecker(tag) {\n    return function (v) { return typeof v === \"object\" && v && nativeToString.call(v) === tag; };\n}\nif (typeof Buffer !== \"undefined\") {\n    exports.basicTypes.Buffer = new BasicType(function (v) { return Buffer.isBuffer(v); }, \"is not a Buffer\");\n}\nvar _loop_1 = function (array_1) {\n    exports.basicTypes[array_1.name] = new BasicType(function (v) { return (v instanceof array_1); }, \"is not a \" + array_1.name);\n};\n// Support typed arrays of various flavors\nfor (var _i = 0, _a = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; _i < _a.length; _i++) {\n    var array_1 = _a[_i];\n    _loop_1(array_1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RzLWludGVyZmFjZS1jaGVja2VyQDAuMS4xMy9ub2RlX21vZHVsZXMvdHMtaW50ZXJmYWNlLWNoZWNrZXIvZGlzdC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLGFBQWEsR0FBRyxpQkFBaUIsR0FBRyxXQUFXLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxvQkFBb0IsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVyxHQUFHLGFBQWEsR0FBRyxZQUFZLEdBQUcsYUFBYTtBQUNoZ0IsYUFBYSxtQkFBTyxDQUFDLHNIQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLENBQUM7QUFDRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxxQ0FBcUM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0Esa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFFQUFxRTtBQUNuSCxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHFDQUFxQztBQUMvRjtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG1EQUFtRDtBQUM3RztBQUNBLDZEQUE2RCw2QkFBNkI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsdUJBQXVCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0JBQW9CO0FBQ3BCO0FBQ0Esb0RBQW9ELDBDQUEwQztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDBEQUEwRDtBQUNuSCw0REFBNEQsOENBQThDO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdDQUFnQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwyQ0FBMkM7QUFDckc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixzQ0FBc0MsY0FBYztBQUNwRCx5Q0FBeUMsaUNBQWlDO0FBQzFFLHlDQUF5QyxzQ0FBc0M7QUFDL0UsMENBQTBDLGtDQUFrQztBQUM1RSx5Q0FBeUMsaUNBQWlDO0FBQzFFLHlDQUF5QyxpQ0FBaUM7QUFDMUUsdUNBQXVDLHFCQUFxQjtBQUM1RCw0Q0FBNEMsMkJBQTJCO0FBQ3ZFLHVDQUF1QyxzQkFBc0I7QUFDN0Qsd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsSUFBSSx5QkFBeUIsZ0NBQWdDLDRCQUE0QjtBQUN6RjtBQUNBO0FBQ0Esb0VBQW9FLGdDQUFnQztBQUNwRztBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsZ0JBQWdCO0FBQ3ZGO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2RvY3MvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RzLWludGVyZmFjZS1jaGVja2VyQDAuMS4xMy9ub2RlX21vZHVsZXMvdHMtaW50ZXJmYWNlLWNoZWNrZXIvZGlzdC90eXBlcy5qcz82YjJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBUaGlzIG1vZHVsZSBkZWZpbmVzIG5vZGVzIHVzZWQgdG8gZGVmaW5lIHR5cGVzIGFuZCB2YWxpZGF0aW9ucyBmb3Igb2JqZWN0cyBhbmQgaW50ZXJmYWNlcy5cbiAqL1xuLy8gdHNsaW50OmRpc2FibGU6bm8tc2hhZG93ZWQtdmFyaWFibGUgcHJlZmVyLWZvci1vZlxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJhc2ljVHlwZXMgPSBleHBvcnRzLkJhc2ljVHlwZSA9IGV4cG9ydHMuVFBhcmFtTGlzdCA9IGV4cG9ydHMuVFBhcmFtID0gZXhwb3J0cy5wYXJhbSA9IGV4cG9ydHMuVEZ1bmMgPSBleHBvcnRzLmZ1bmMgPSBleHBvcnRzLlRQcm9wID0gZXhwb3J0cy5UT3B0aW9uYWwgPSBleHBvcnRzLm9wdCA9IGV4cG9ydHMuVElmYWNlID0gZXhwb3J0cy5pZmFjZSA9IGV4cG9ydHMuVEVudW1MaXRlcmFsID0gZXhwb3J0cy5lbnVtbGl0ID0gZXhwb3J0cy5URW51bVR5cGUgPSBleHBvcnRzLmVudW10eXBlID0gZXhwb3J0cy5USW50ZXJzZWN0aW9uID0gZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBleHBvcnRzLlRVbmlvbiA9IGV4cG9ydHMudW5pb24gPSBleHBvcnRzLlRUdXBsZSA9IGV4cG9ydHMudHVwbGUgPSBleHBvcnRzLlRBcnJheSA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLlRMaXRlcmFsID0gZXhwb3J0cy5saXQgPSBleHBvcnRzLlROYW1lID0gZXhwb3J0cy5uYW1lID0gZXhwb3J0cy5UVHlwZSA9IHZvaWQgMDtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuLyoqIE5vZGUgdGhhdCByZXByZXNlbnRzIGEgdHlwZS4gKi9cbnZhciBUVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUVHlwZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFRUeXBlO1xufSgpKTtcbmV4cG9ydHMuVFR5cGUgPSBUVHlwZTtcbi8qKiBQYXJzZXMgYSB0eXBlIHNwZWMgaW50byBhIFRUeXBlIG5vZGUuICovXG5mdW5jdGlvbiBwYXJzZVNwZWModHlwZVNwZWMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHR5cGVTcGVjID09PSBcInN0cmluZ1wiID8gbmFtZSh0eXBlU3BlYykgOiB0eXBlU3BlYztcbn1cbmZ1bmN0aW9uIGdldE5hbWVkVHlwZShzdWl0ZSwgbmFtZSkge1xuICAgIHZhciB0dHlwZSA9IHN1aXRlW25hbWVdO1xuICAgIGlmICghdHR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIFwiICsgbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0dHlwZTtcbn1cbi8qKlxuICogRGVmaW5lcyBhIHR5cGUgbmFtZSwgZWl0aGVyIGJ1aWx0LWluLCBvciBkZWZpbmVkIGluIHRoaXMgc3VpdGUuIEl0IGNhbiB0eXBpY2FsbHkgYmUgaW5jbHVkZWQgaW5cbiAqIHRoZSBzcGVjcyBhcyBqdXN0IGEgcGxhaW4gc3RyaW5nLlxuICovXG5mdW5jdGlvbiBuYW1lKHZhbHVlKSB7IHJldHVybiBuZXcgVE5hbWUodmFsdWUpOyB9XG5leHBvcnRzLm5hbWUgPSBuYW1lO1xudmFyIFROYW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUTmFtZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUTmFtZShuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5fZmFpbE1zZyA9IFwiaXMgbm90IGEgXCIgKyBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFROYW1lLnByb3RvdHlwZS5nZXRDaGVja2VyID0gZnVuY3Rpb24gKHN1aXRlLCBzdHJpY3QsIGFsbG93ZWRQcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdHR5cGUgPSBnZXROYW1lZFR5cGUoc3VpdGUsIHRoaXMubmFtZSk7XG4gICAgICAgIHZhciBjaGVja2VyID0gdHR5cGUuZ2V0Q2hlY2tlcihzdWl0ZSwgc3RyaWN0LCBhbGxvd2VkUHJvcHMpO1xuICAgICAgICBpZiAodHR5cGUgaW5zdGFuY2VvZiBCYXNpY1R5cGUgfHwgdHR5cGUgaW5zdGFuY2VvZiBUTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIGNvbXBsZXggdHlwZXMsIGFkZCBhbiBhZGRpdGlvbmFsIFwiaXMgbm90IGEgPFR5cGU+XCIgbWVzc2FnZSBvbiBmYWlsdXJlLlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBjdHgpIHsgcmV0dXJuIGNoZWNrZXIodmFsdWUsIGN0eCkgPyB0cnVlIDogY3R4LmZhaWwobnVsbCwgX3RoaXMuX2ZhaWxNc2csIDApOyB9O1xuICAgIH07XG4gICAgcmV0dXJuIFROYW1lO1xufShUVHlwZSkpO1xuZXhwb3J0cy5UTmFtZSA9IFROYW1lO1xuLyoqXG4gKiBEZWZpbmVzIGEgbGl0ZXJhbCB2YWx1ZSwgZS5nLiBsaXQoJ2hlbGxvJykgb3IgbGl0KDEyMykuXG4gKi9cbmZ1bmN0aW9uIGxpdCh2YWx1ZSkgeyByZXR1cm4gbmV3IFRMaXRlcmFsKHZhbHVlKTsgfVxuZXhwb3J0cy5saXQgPSBsaXQ7XG52YXIgVExpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRMaXRlcmFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIF90aGlzLm5hbWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIF90aGlzLl9mYWlsTXNnID0gXCJpcyBub3QgXCIgKyBfdGhpcy5uYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRMaXRlcmFsLnByb3RvdHlwZS5nZXRDaGVja2VyID0gZnVuY3Rpb24gKHN1aXRlLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7IHJldHVybiAodmFsdWUgPT09IF90aGlzLnZhbHVlKSA/IHRydWUgOiBjdHguZmFpbChudWxsLCBfdGhpcy5fZmFpbE1zZywgLTEpOyB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRMaXRlcmFsO1xufShUVHlwZSkpO1xuZXhwb3J0cy5UTGl0ZXJhbCA9IFRMaXRlcmFsO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGFycmF5IHR5cGUsIGUuZy4gYXJyYXkoJ251bWJlcicpLlxuICovXG5mdW5jdGlvbiBhcnJheSh0eXBlU3BlYykgeyByZXR1cm4gbmV3IFRBcnJheShwYXJzZVNwZWModHlwZVNwZWMpKTsgfVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xudmFyIFRBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVEFycmF5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRBcnJheSh0dHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50dHlwZSA9IHR0eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRBcnJheS5wcm90b3R5cGUuZ2V0Q2hlY2tlciA9IGZ1bmN0aW9uIChzdWl0ZSwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpdGVtQ2hlY2tlciA9IHRoaXMudHR5cGUuZ2V0Q2hlY2tlcihzdWl0ZSwgc3RyaWN0KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5mYWlsKG51bGwsIFwiaXMgbm90IGFuIGFycmF5XCIsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvayA9IGl0ZW1DaGVja2VyKHZhbHVlW2ldLCBjdHgpO1xuICAgICAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5mYWlsKGksIG51bGwsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRBcnJheTtcbn0oVFR5cGUpKTtcbmV4cG9ydHMuVEFycmF5ID0gVEFycmF5O1xuLyoqXG4gKiBEZWZpbmVzIGEgdHVwbGUgdHlwZSwgZS5nLiB0dXBsZSgnc3RyaW5nJywgJ251bWJlcicpLlxuICovXG5mdW5jdGlvbiB0dXBsZSgpIHtcbiAgICB2YXIgdHlwZVNwZWMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0eXBlU3BlY1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRUdXBsZSh0eXBlU3BlYy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHBhcnNlU3BlYyh0KTsgfSkpO1xufVxuZXhwb3J0cy50dXBsZSA9IHR1cGxlO1xudmFyIFRUdXBsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVFR1cGxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRUdXBsZSh0dHlwZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHR5cGVzID0gdHR5cGVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRUdXBsZS5wcm90b3R5cGUuZ2V0Q2hlY2tlciA9IGZ1bmN0aW9uIChzdWl0ZSwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpdGVtQ2hlY2tlcnMgPSB0aGlzLnR0eXBlcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuZ2V0Q2hlY2tlcihzdWl0ZSwgc3RyaWN0KTsgfSk7XG4gICAgICAgIHZhciBjaGVja2VyID0gZnVuY3Rpb24gKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmZhaWwobnVsbCwgXCJpcyBub3QgYW4gYXJyYXlcIiwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1DaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvayA9IGl0ZW1DaGVja2Vyc1tpXSh2YWx1ZVtpXSwgY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguZmFpbChpLCBudWxsLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgaWYgKCFjaGVja2VyKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA8PSBpdGVtQ2hlY2tlcnMubGVuZ3RoID8gdHJ1ZSA6XG4gICAgICAgICAgICAgICAgY3R4LmZhaWwoaXRlbUNoZWNrZXJzLmxlbmd0aCwgXCJpcyBleHRyYW5lb3VzXCIsIDIpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRUdXBsZTtcbn0oVFR5cGUpKTtcbmV4cG9ydHMuVFR1cGxlID0gVFR1cGxlO1xuLyoqXG4gKiBEZWZpbmVzIGEgdW5pb24gdHlwZSwgZS5nLiB1bmlvbignbnVtYmVyJywgJ251bGwnKS5cbiAqL1xuZnVuY3Rpb24gdW5pb24oKSB7XG4gICAgdmFyIHR5cGVTcGVjID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdHlwZVNwZWNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUVW5pb24odHlwZVNwZWMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBwYXJzZVNwZWModCk7IH0pKTtcbn1cbmV4cG9ydHMudW5pb24gPSB1bmlvbjtcbnZhciBUVW5pb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRVbmlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUVW5pb24odHR5cGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR0eXBlcyA9IHR0eXBlcztcbiAgICAgICAgdmFyIG5hbWVzID0gdHR5cGVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdCBpbnN0YW5jZW9mIFROYW1lIHx8IHQgaW5zdGFuY2VvZiBUTGl0ZXJhbCA/IHQubmFtZSA6IG51bGw7IH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuOyB9KTtcbiAgICAgICAgdmFyIG90aGVyVHlwZXMgPSB0dHlwZXMubGVuZ3RoIC0gbmFtZXMubGVuZ3RoO1xuICAgICAgICBpZiAobmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAob3RoZXJUeXBlcyA+IDApIHtcbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKG90aGVyVHlwZXMgKyBcIiBtb3JlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX2ZhaWxNc2cgPSBcImlzIG5vbmUgb2YgXCIgKyBuYW1lcy5qb2luKFwiLCBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5fZmFpbE1zZyA9IFwiaXMgbm9uZSBvZiBcIiArIG90aGVyVHlwZXMgKyBcIiB0eXBlc1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVFVuaW9uLnByb3RvdHlwZS5nZXRDaGVja2VyID0gZnVuY3Rpb24gKHN1aXRlLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGl0ZW1DaGVja2VycyA9IHRoaXMudHR5cGVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5nZXRDaGVja2VyKHN1aXRlLCBzdHJpY3QpOyB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICB2YXIgdXIgPSBjdHgudW5pb25SZXNvbHZlcigpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2sgPSBpdGVtQ2hlY2tlcnNbaV0odmFsdWUsIHVyLmNyZWF0ZUNvbnRleHQoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXNvbHZlVW5pb24odXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5mYWlsKG51bGwsIF90aGlzLl9mYWlsTXNnLCAwKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUVW5pb247XG59KFRUeXBlKSk7XG5leHBvcnRzLlRVbmlvbiA9IFRVbmlvbjtcbi8qKlxuICogRGVmaW5lcyBhbiBpbnRlcnNlY3Rpb24gdHlwZSwgZS5nLiBpbnRlcnNlY3Rpb24oJ251bWJlcicsICdudWxsJykuXG4gKi9cbmZ1bmN0aW9uIGludGVyc2VjdGlvbigpIHtcbiAgICB2YXIgdHlwZVNwZWMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0eXBlU3BlY1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRJbnRlcnNlY3Rpb24odHlwZVNwZWMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBwYXJzZVNwZWModCk7IH0pKTtcbn1cbmV4cG9ydHMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xudmFyIFRJbnRlcnNlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRJbnRlcnNlY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVEludGVyc2VjdGlvbih0dHlwZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHR5cGVzID0gdHR5cGVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRJbnRlcnNlY3Rpb24ucHJvdG90eXBlLmdldENoZWNrZXIgPSBmdW5jdGlvbiAoc3VpdGUsIHN0cmljdCkge1xuICAgICAgICB2YXIgYWxsb3dlZFByb3BzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgaXRlbUNoZWNrZXJzID0gdGhpcy50dHlwZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmdldENoZWNrZXIoc3VpdGUsIHN0cmljdCwgYWxsb3dlZFByb3BzKTsgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgdmFyIG9rID0gaXRlbUNoZWNrZXJzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVja2VyKSB7IHJldHVybiBjaGVja2VyKHZhbHVlLCBjdHgpOyB9KTtcbiAgICAgICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN0eC5mYWlsKG51bGwsIG51bGwsIDApO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRJbnRlcnNlY3Rpb247XG59KFRUeXBlKSk7XG5leHBvcnRzLlRJbnRlcnNlY3Rpb24gPSBUSW50ZXJzZWN0aW9uO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGVudW0gdHlwZSwgZS5nLiBlbnVtKHsnQSc6IDEsICdCJzogMn0pLlxuICovXG5mdW5jdGlvbiBlbnVtdHlwZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IFRFbnVtVHlwZSh2YWx1ZXMpO1xufVxuZXhwb3J0cy5lbnVtdHlwZSA9IGVudW10eXBlO1xudmFyIFRFbnVtVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVEVudW1UeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRFbnVtVHlwZShtZW1iZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1lbWJlcnMgPSBtZW1iZXJzO1xuICAgICAgICBfdGhpcy52YWxpZFZhbHVlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgX3RoaXMuX2ZhaWxNc2cgPSBcImlzIG5vdCBhIHZhbGlkIGVudW0gdmFsdWVcIjtcbiAgICAgICAgX3RoaXMudmFsaWRWYWx1ZXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKG1lbWJlcnMpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWVtYmVyc1tuYW1lXTsgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRFbnVtVHlwZS5wcm90b3R5cGUuZ2V0Q2hlY2tlciA9IGZ1bmN0aW9uIChzdWl0ZSwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIChfdGhpcy52YWxpZFZhbHVlcy5oYXModmFsdWUpID8gdHJ1ZSA6IGN0eC5mYWlsKG51bGwsIF90aGlzLl9mYWlsTXNnLCAwKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVEVudW1UeXBlO1xufShUVHlwZSkpO1xuZXhwb3J0cy5URW51bVR5cGUgPSBURW51bVR5cGU7XG4vKipcbiAqIERlZmluZXMgYSBsaXRlcmFsIGVudW0gdmFsdWUsIHN1Y2ggYXMgRGlyZWN0aW9uLlVwLCBzcGVjaWZpZWQgYXMgZW51bWxpdChcIkRpcmVjdGlvblwiLCBcIlVwXCIpLlxuICovXG5mdW5jdGlvbiBlbnVtbGl0KG5hbWUsIHByb3ApIHtcbiAgICByZXR1cm4gbmV3IFRFbnVtTGl0ZXJhbChuYW1lLCBwcm9wKTtcbn1cbmV4cG9ydHMuZW51bWxpdCA9IGVudW1saXQ7XG52YXIgVEVudW1MaXRlcmFsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhURW51bUxpdGVyYWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVEVudW1MaXRlcmFsKGVudW1OYW1lLCBwcm9wKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVudW1OYW1lID0gZW51bU5hbWU7XG4gICAgICAgIF90aGlzLnByb3AgPSBwcm9wO1xuICAgICAgICBfdGhpcy5fZmFpbE1zZyA9IFwiaXMgbm90IFwiICsgZW51bU5hbWUgKyBcIi5cIiArIHByb3A7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVEVudW1MaXRlcmFsLnByb3RvdHlwZS5nZXRDaGVja2VyID0gZnVuY3Rpb24gKHN1aXRlLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHR0eXBlID0gZ2V0TmFtZWRUeXBlKHN1aXRlLCB0aGlzLmVudW1OYW1lKTtcbiAgICAgICAgaWYgKCEodHR5cGUgaW5zdGFuY2VvZiBURW51bVR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIFwiICsgdGhpcy5lbnVtTmFtZSArIFwiIHVzZWQgaW4gZW51bWxpdCBpcyBub3QgYW4gZW51bSB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWwgPSB0dHlwZS5tZW1iZXJzW3RoaXMucHJvcF07XG4gICAgICAgIGlmICghdHR5cGUubWVtYmVycy5oYXNPd25Qcm9wZXJ0eSh0aGlzLnByb3ApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHZhbHVlIFwiICsgdGhpcy5lbnVtTmFtZSArIFwiLlwiICsgdGhpcy5wcm9wICsgXCIgdXNlZCBpbiBlbnVtbGl0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGN0eCkgeyByZXR1cm4gKHZhbHVlID09PSB2YWwpID8gdHJ1ZSA6IGN0eC5mYWlsKG51bGwsIF90aGlzLl9mYWlsTXNnLCAtMSk7IH07XG4gICAgfTtcbiAgICByZXR1cm4gVEVudW1MaXRlcmFsO1xufShUVHlwZSkpO1xuZXhwb3J0cy5URW51bUxpdGVyYWwgPSBURW51bUxpdGVyYWw7XG5mdW5jdGlvbiBtYWtlSWZhY2VQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwcm9wcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYWtlSWZhY2VQcm9wKG5hbWUsIHByb3BzW25hbWVdKTsgfSk7XG59XG5mdW5jdGlvbiBtYWtlSWZhY2VQcm9wKG5hbWUsIHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCBpbnN0YW5jZW9mIFRPcHRpb25hbCA/XG4gICAgICAgIG5ldyBUUHJvcChuYW1lLCBwcm9wLnR0eXBlLCB0cnVlKSA6XG4gICAgICAgIG5ldyBUUHJvcChuYW1lLCBwYXJzZVNwZWMocHJvcCksIGZhbHNlKTtcbn1cbi8qKlxuICogRGVmaW5lcyBhbiBpbnRlcmZhY2UuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBhcnJheSBvZiBpbnRlcmZhY2VzIHRoYXQgaXQgZXh0ZW5kcywgYW5kIHRoZVxuICogc2Vjb25kIGlzIGFuIGFycmF5IG9mIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGlmYWNlKGJhc2VzLCBwcm9wcykge1xuICAgIHJldHVybiBuZXcgVElmYWNlKGJhc2VzLCBtYWtlSWZhY2VQcm9wcyhwcm9wcykpO1xufVxuZXhwb3J0cy5pZmFjZSA9IGlmYWNlO1xudmFyIFRJZmFjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVElmYWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRJZmFjZShiYXNlcywgcHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYmFzZXMgPSBiYXNlcztcbiAgICAgICAgX3RoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgX3RoaXMucHJvcFNldCA9IG5ldyBTZXQocHJvcHMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLm5hbWU7IH0pKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUSWZhY2UucHJvdG90eXBlLmdldENoZWNrZXIgPSBmdW5jdGlvbiAoc3VpdGUsIHN0cmljdCwgYWxsb3dlZFByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBiYXNlQ2hlY2tlcnMgPSB0aGlzLmJhc2VzLm1hcChmdW5jdGlvbiAoYikgeyByZXR1cm4gZ2V0TmFtZWRUeXBlKHN1aXRlLCBiKS5nZXRDaGVja2VyKHN1aXRlLCBzdHJpY3QpOyB9KTtcbiAgICAgICAgdmFyIHByb3BDaGVja2VycyA9IHRoaXMucHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwcm9wLnR0eXBlLmdldENoZWNrZXIoc3VpdGUsIHN0cmljdCk7IH0pO1xuICAgICAgICB2YXIgdGVzdEN0eCA9IG5ldyB1dGlsXzEuTm9vcENvbnRleHQoKTtcbiAgICAgICAgLy8gQ29uc2lkZXIgYSBwcm9wIHJlcXVpcmVkIGlmIGl0J3Mgbm90IG9wdGlvbmFsIEFORCBkb2VzIG5vdCBhbGxvdyBmb3IgdW5kZWZpbmVkIGFzIGEgdmFsdWUuXG4gICAgICAgIHZhciBpc1Byb3BSZXF1aXJlZCA9IHRoaXMucHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gIXByb3AuaXNPcHQgJiYgIXByb3BDaGVja2Vyc1tpXSh1bmRlZmluZWQsIHRlc3RDdHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBmdW5jdGlvbiAodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHguZmFpbChudWxsLCBcImlzIG5vdCBhbiBvYmplY3RcIiwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZUNoZWNrZXJzW2ldKHZhbHVlLCBjdHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBfdGhpcy5wcm9wc1tpXS5uYW1lO1xuICAgICAgICAgICAgICAgIHZhciB2ID0gdmFsdWVbbmFtZV8xXTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3BSZXF1aXJlZFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5mYWlsKG5hbWVfMSwgXCJpcyBtaXNzaW5nXCIsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2sgPSBwcm9wQ2hlY2tlcnNbaV0odiwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5mYWlsKG5hbWVfMSwgbnVsbCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja2VyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wU2V0ID0gdGhpcy5wcm9wU2V0O1xuICAgICAgICBpZiAoYWxsb3dlZFByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BTZXQuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gYWxsb3dlZFByb3BzLmFkZChwcm9wKTsgfSk7XG4gICAgICAgICAgICBwcm9wU2V0ID0gYWxsb3dlZFByb3BzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIHN0cmljdCBtb2RlLCBjaGVjayBhbHNvIGZvciB1bmtub3duIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrZXIodmFsdWUsIGN0eCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wU2V0Lmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmZhaWwocHJvcCwgXCJpcyBleHRyYW5lb3VzXCIsIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRJZmFjZTtcbn0oVFR5cGUpKTtcbmV4cG9ydHMuVElmYWNlID0gVElmYWNlO1xuLyoqXG4gKiBEZWZpbmVzIGFuIG9wdGlvbmFsIHByb3BlcnR5IG9uIGFuIGludGVyZmFjZS5cbiAqL1xuZnVuY3Rpb24gb3B0KHR5cGVTcGVjKSB7IHJldHVybiBuZXcgVE9wdGlvbmFsKHBhcnNlU3BlYyh0eXBlU3BlYykpOyB9XG5leHBvcnRzLm9wdCA9IG9wdDtcbnZhciBUT3B0aW9uYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRPcHRpb25hbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUT3B0aW9uYWwodHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHR5cGUgPSB0dHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUT3B0aW9uYWwucHJvdG90eXBlLmdldENoZWNrZXIgPSBmdW5jdGlvbiAoc3VpdGUsIHN0cmljdCkge1xuICAgICAgICB2YXIgaXRlbUNoZWNrZXIgPSB0aGlzLnR0eXBlLmdldENoZWNrZXIoc3VpdGUsIHN0cmljdCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgfHwgaXRlbUNoZWNrZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gVE9wdGlvbmFsO1xufShUVHlwZSkpO1xuZXhwb3J0cy5UT3B0aW9uYWwgPSBUT3B0aW9uYWw7XG4vKipcbiAqIERlZmluZXMgYSBwcm9wZXJ0eSBpbiBhbiBpbnRlcmZhY2UuXG4gKi9cbnZhciBUUHJvcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUUHJvcChuYW1lLCB0dHlwZSwgaXNPcHQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50dHlwZSA9IHR0eXBlO1xuICAgICAgICB0aGlzLmlzT3B0ID0gaXNPcHQ7XG4gICAgfVxuICAgIHJldHVybiBUUHJvcDtcbn0oKSk7XG5leHBvcnRzLlRQcm9wID0gVFByb3A7XG4vKipcbiAqIERlZmluZXMgYSBmdW5jdGlvbi4gVGhlIGZpcnN0IGFyZ3VtZW50IGRlY2xhcmVzIHRoZSBmdW5jdGlvbidzIHJldHVybiB0eXBlLCB0aGUgcmVzdCBkZWNsYXJlXG4gKiBpdHMgcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gZnVuYyhyZXN1bHRTcGVjKSB7XG4gICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBURnVuYyhuZXcgVFBhcmFtTGlzdChwYXJhbXMpLCBwYXJzZVNwZWMocmVzdWx0U3BlYykpO1xufVxuZXhwb3J0cy5mdW5jID0gZnVuYztcbnZhciBURnVuYyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVEZ1bmMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVEZ1bmMocGFyYW1MaXN0LCByZXN1bHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFyYW1MaXN0ID0gcGFyYW1MaXN0O1xuICAgICAgICBfdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVEZ1bmMucHJvdG90eXBlLmdldENoZWNrZXIgPSBmdW5jdGlvbiAoc3VpdGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHRydWUgOiBjdHguZmFpbChudWxsLCBcImlzIG5vdCBhIGZ1bmN0aW9uXCIsIDApO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRGdW5jO1xufShUVHlwZSkpO1xuZXhwb3J0cy5URnVuYyA9IFRGdW5jO1xuLyoqXG4gKiBEZWZpbmVzIGEgZnVuY3Rpb24gcGFyYW1ldGVyLlxuICovXG5mdW5jdGlvbiBwYXJhbShuYW1lLCB0eXBlU3BlYywgaXNPcHQpIHtcbiAgICByZXR1cm4gbmV3IFRQYXJhbShuYW1lLCBwYXJzZVNwZWModHlwZVNwZWMpLCBCb29sZWFuKGlzT3B0KSk7XG59XG5leHBvcnRzLnBhcmFtID0gcGFyYW07XG52YXIgVFBhcmFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRQYXJhbShuYW1lLCB0dHlwZSwgaXNPcHQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50dHlwZSA9IHR0eXBlO1xuICAgICAgICB0aGlzLmlzT3B0ID0gaXNPcHQ7XG4gICAgfVxuICAgIHJldHVybiBUUGFyYW07XG59KCkpO1xuZXhwb3J0cy5UUGFyYW0gPSBUUGFyYW07XG4vKipcbiAqIERlZmluZXMgYSBmdW5jdGlvbiBwYXJhbWV0ZXIgbGlzdC5cbiAqL1xudmFyIFRQYXJhbUxpc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRQYXJhbUxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVFBhcmFtTGlzdChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRQYXJhbUxpc3QucHJvdG90eXBlLmdldENoZWNrZXIgPSBmdW5jdGlvbiAoc3VpdGUsIHN0cmljdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaXRlbUNoZWNrZXJzID0gdGhpcy5wYXJhbXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LnR0eXBlLmdldENoZWNrZXIoc3VpdGUsIHN0cmljdCk7IH0pO1xuICAgICAgICB2YXIgdGVzdEN0eCA9IG5ldyB1dGlsXzEuTm9vcENvbnRleHQoKTtcbiAgICAgICAgdmFyIGlzUGFyYW1SZXF1aXJlZCA9IHRoaXMucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0sIGkpIHtcbiAgICAgICAgICAgIHJldHVybiAhcGFyYW0uaXNPcHQgJiYgIWl0ZW1DaGVja2Vyc1tpXSh1bmRlZmluZWQsIHRlc3RDdHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBmdW5jdGlvbiAodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHguZmFpbChudWxsLCBcImlzIG5vdCBhbiBhcnJheVwiLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBfdGhpcy5wYXJhbXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFyYW1SZXF1aXJlZFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5mYWlsKHAubmFtZSwgXCJpcyBtaXNzaW5nXCIsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2sgPSBpdGVtQ2hlY2tlcnNbaV0odmFsdWVbaV0sIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguZmFpbChwLm5hbWUsIG51bGwsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghc3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tlcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPD0gaXRlbUNoZWNrZXJzLmxlbmd0aCA/IHRydWUgOlxuICAgICAgICAgICAgICAgIGN0eC5mYWlsKGl0ZW1DaGVja2Vycy5sZW5ndGgsIFwiaXMgZXh0cmFuZW91c1wiLCAyKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUUGFyYW1MaXN0O1xufShUVHlwZSkpO1xuZXhwb3J0cy5UUGFyYW1MaXN0ID0gVFBhcmFtTGlzdDtcbi8qKlxuICogU2luZ2xlIFRUeXBlIGltcGxlbWVudGF0aW9uIGZvciBhbGwgYmFzaWMgYnVpbHQtaW4gdHlwZXMuXG4gKi9cbnZhciBCYXNpY1R5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2ljVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXNpY1R5cGUodmFsaWRhdG9yLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmFzaWNUeXBlLnByb3RvdHlwZS5nZXRDaGVja2VyID0gZnVuY3Rpb24gKHN1aXRlLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgY3R4KSB7IHJldHVybiBfdGhpcy52YWxpZGF0b3IodmFsdWUpID8gdHJ1ZSA6IGN0eC5mYWlsKG51bGwsIF90aGlzLm1lc3NhZ2UsIDApOyB9O1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2ljVHlwZTtcbn0oVFR5cGUpKTtcbmV4cG9ydHMuQmFzaWNUeXBlID0gQmFzaWNUeXBlO1xuLyoqXG4gKiBEZWZpbmVzIHRoZSBzdWl0ZSBvZiBiYXNpYyB0eXBlcy5cbiAqL1xuZXhwb3J0cy5iYXNpY1R5cGVzID0ge1xuICAgIGFueTogbmV3IEJhc2ljVHlwZShmdW5jdGlvbiAodikgeyByZXR1cm4gdHJ1ZTsgfSwgXCJpcyBpbnZhbGlkXCIpLFxuICAgIG51bWJlcjogbmV3IEJhc2ljVHlwZShmdW5jdGlvbiAodikgeyByZXR1cm4gKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKTsgfSwgXCJpcyBub3QgYSBudW1iZXJcIiksXG4gICAgb2JqZWN0OiBuZXcgQmFzaWNUeXBlKGZ1bmN0aW9uICh2KSB7IHJldHVybiAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdik7IH0sIFwiaXMgbm90IGFuIG9iamVjdFwiKSxcbiAgICBib29sZWFuOiBuZXcgQmFzaWNUeXBlKGZ1bmN0aW9uICh2KSB7IHJldHVybiAodHlwZW9mIHYgPT09IFwiYm9vbGVhblwiKTsgfSwgXCJpcyBub3QgYSBib29sZWFuXCIpLFxuICAgIHN0cmluZzogbmV3IEJhc2ljVHlwZShmdW5jdGlvbiAodikgeyByZXR1cm4gKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKTsgfSwgXCJpcyBub3QgYSBzdHJpbmdcIiksXG4gICAgc3ltYm9sOiBuZXcgQmFzaWNUeXBlKGZ1bmN0aW9uICh2KSB7IHJldHVybiAodHlwZW9mIHYgPT09IFwic3ltYm9sXCIpOyB9LCBcImlzIG5vdCBhIHN5bWJvbFwiKSxcbiAgICB2b2lkOiBuZXcgQmFzaWNUeXBlKGZ1bmN0aW9uICh2KSB7IHJldHVybiAodiA9PSBudWxsKTsgfSwgXCJpcyBub3Qgdm9pZFwiKSxcbiAgICB1bmRlZmluZWQ6IG5ldyBCYXNpY1R5cGUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2ID09PSB1bmRlZmluZWQpOyB9LCBcImlzIG5vdCB1bmRlZmluZWRcIiksXG4gICAgbnVsbDogbmV3IEJhc2ljVHlwZShmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgPT09IG51bGwpOyB9LCBcImlzIG5vdCBudWxsXCIpLFxuICAgIG5ldmVyOiBuZXcgQmFzaWNUeXBlKGZ1bmN0aW9uICh2KSB7IHJldHVybiBmYWxzZTsgfSwgXCJpcyB1bmV4cGVjdGVkXCIpLFxuICAgIERhdGU6IG5ldyBCYXNpY1R5cGUoZ2V0SXNOYXRpdmVDaGVja2VyKFwiW29iamVjdCBEYXRlXVwiKSwgXCJpcyBub3QgYSBEYXRlXCIpLFxuICAgIFJlZ0V4cDogbmV3IEJhc2ljVHlwZShnZXRJc05hdGl2ZUNoZWNrZXIoXCJbb2JqZWN0IFJlZ0V4cF1cIiksIFwiaXMgbm90IGEgUmVnRXhwXCIpLFxufTtcbi8vIFRoaXMgYXBwcm9hY2ggZm9yIGNoZWNraW5nIG5hdGl2ZSBvYmplY3QgdHlwZXMgbWlycm9ycyB0aGF0IG9mIGxvZGFzaC4gSXRzIGFkdmFudGFnZSBvdmVyXG4vLyBgaXNpbnN0YW5jZWAgaXMgdGhhdCBpdCBjYW4gc3RpbGwgcmV0dXJuIHRydWUgZm9yIG5hdGl2ZSBvYmplY3RzIGNyZWF0ZWQgaW4gZGlmZmVyZW50IEpTXG4vLyBleGVjdXRpb24gZW52aXJvbm1lbnRzLlxudmFyIG5hdGl2ZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmZ1bmN0aW9uIGdldElzTmF0aXZlQ2hlY2tlcih0YWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgJiYgbmF0aXZlVG9TdHJpbmcuY2FsbCh2KSA9PT0gdGFnOyB9O1xufVxuaWYgKHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBleHBvcnRzLmJhc2ljVHlwZXMuQnVmZmVyID0gbmV3IEJhc2ljVHlwZShmdW5jdGlvbiAodikgeyByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHYpOyB9LCBcImlzIG5vdCBhIEJ1ZmZlclwiKTtcbn1cbnZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGFycmF5XzEpIHtcbiAgICBleHBvcnRzLmJhc2ljVHlwZXNbYXJyYXlfMS5uYW1lXSA9IG5ldyBCYXNpY1R5cGUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2IGluc3RhbmNlb2YgYXJyYXlfMSk7IH0sIFwiaXMgbm90IGEgXCIgKyBhcnJheV8xLm5hbWUpO1xufTtcbi8vIFN1cHBvcnQgdHlwZWQgYXJyYXlzIG9mIHZhcmlvdXMgZmxhdm9yc1xuZm9yICh2YXIgX2kgPSAwLCBfYSA9IFtJbnQ4QXJyYXksIFVpbnQ4QXJyYXksIFVpbnQ4Q2xhbXBlZEFycmF5LCBJbnQxNkFycmF5LCBVaW50MTZBcnJheSxcbiAgICBJbnQzMkFycmF5LCBVaW50MzJBcnJheSwgRmxvYXQzMkFycmF5LCBGbG9hdDY0QXJyYXksIEFycmF5QnVmZmVyXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgYXJyYXlfMSA9IF9hW19pXTtcbiAgICBfbG9vcF8xKGFycmF5XzEpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/types.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/util.js":
/*!********************************************************************************************************!*\
  !*** ../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/util.js ***!
  \********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DetailContext = exports.NoopContext = exports.VError = void 0;\n/**\n * Error thrown by validation. Besides an informative message, it includes the path to the\n * property which triggered the failure.\n */\nvar VError = /** @class */ (function (_super) {\n    __extends(VError, _super);\n    function VError(path, message) {\n        var _this = _super.call(this, message) || this;\n        _this.path = path;\n        // See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work for info about this workaround.\n        Object.setPrototypeOf(_this, VError.prototype);\n        return _this;\n    }\n    return VError;\n}(Error));\nexports.VError = VError;\n/**\n * Fast implementation of IContext used for first-pass validation. If that fails, we can validate\n * using DetailContext to collect error messages. That's faster for the common case when messages\n * normally pass validation.\n */\nvar NoopContext = /** @class */ (function () {\n    function NoopContext() {\n    }\n    NoopContext.prototype.fail = function (relPath, message, score) {\n        return false;\n    };\n    NoopContext.prototype.unionResolver = function () { return this; };\n    NoopContext.prototype.createContext = function () { return this; };\n    NoopContext.prototype.resolveUnion = function (ur) { };\n    return NoopContext;\n}());\nexports.NoopContext = NoopContext;\n/**\n * Complete implementation of IContext that collects meaningfull errors.\n */\nvar DetailContext = /** @class */ (function () {\n    function DetailContext() {\n        // Stack of property names and associated messages for reporting helpful error messages.\n        this._propNames = [\"\"];\n        this._messages = [null];\n        // Score is used to choose the best union member whose DetailContext to use for reporting.\n        // Higher score means better match (or rather less severe mismatch).\n        this._score = 0;\n    }\n    DetailContext.prototype.fail = function (relPath, message, score) {\n        this._propNames.push(relPath);\n        this._messages.push(message);\n        this._score += score;\n        return false;\n    };\n    DetailContext.prototype.unionResolver = function () {\n        return new DetailUnionResolver();\n    };\n    DetailContext.prototype.resolveUnion = function (unionResolver) {\n        var _a, _b;\n        var u = unionResolver;\n        var best = null;\n        for (var _i = 0, _c = u.contexts; _i < _c.length; _i++) {\n            var ctx = _c[_i];\n            if (!best || ctx._score >= best._score) {\n                best = ctx;\n            }\n        }\n        if (best && best._score > 0) {\n            (_a = this._propNames).push.apply(_a, best._propNames);\n            (_b = this._messages).push.apply(_b, best._messages);\n        }\n    };\n    DetailContext.prototype.getError = function (path) {\n        var msgParts = [];\n        for (var i = this._propNames.length - 1; i >= 0; i--) {\n            var p = this._propNames[i];\n            path += (typeof p === \"number\") ? \"[\" + p + \"]\" : (p ? \".\" + p : \"\");\n            var m = this._messages[i];\n            if (m) {\n                msgParts.push(path + \" \" + m);\n            }\n        }\n        return new VError(path, msgParts.join(\"; \"));\n    };\n    DetailContext.prototype.getErrorDetail = function (path) {\n        var details = [];\n        for (var i = this._propNames.length - 1; i >= 0; i--) {\n            var p = this._propNames[i];\n            path += (typeof p === \"number\") ? \"[\" + p + \"]\" : (p ? \".\" + p : \"\");\n            var message = this._messages[i];\n            if (message) {\n                details.push({ path: path, message: message });\n            }\n        }\n        var detail = null;\n        for (var i = details.length - 1; i >= 0; i--) {\n            if (detail) {\n                details[i].nested = [detail];\n            }\n            detail = details[i];\n        }\n        return detail;\n    };\n    return DetailContext;\n}());\nexports.DetailContext = DetailContext;\nvar DetailUnionResolver = /** @class */ (function () {\n    function DetailUnionResolver() {\n        this.contexts = [];\n    }\n    DetailUnionResolver.prototype.createContext = function () {\n        var ctx = new DetailContext();\n        this.contexts.push(ctx);\n        return ctx;\n    };\n    return DetailUnionResolver;\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RzLWludGVyZmFjZS1jaGVja2VyQDAuMS4xMy9ub2RlX21vZHVsZXMvdHMtaW50ZXJmYWNlLWNoZWNrZXIvZGlzdC91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUN2Riw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsbUJBQW1CLEdBQUcsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsOEJBQThCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RvY3MvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3RzLWludGVyZmFjZS1jaGVja2VyQDAuMS4xMy9ub2RlX21vZHVsZXMvdHMtaW50ZXJmYWNlLWNoZWNrZXIvZGlzdC91dGlsLmpzP2UzNGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGV0YWlsQ29udGV4dCA9IGV4cG9ydHMuTm9vcENvbnRleHQgPSBleHBvcnRzLlZFcnJvciA9IHZvaWQgMDtcbi8qKlxuICogRXJyb3IgdGhyb3duIGJ5IHZhbGlkYXRpb24uIEJlc2lkZXMgYW4gaW5mb3JtYXRpdmUgbWVzc2FnZSwgaXQgaW5jbHVkZXMgdGhlIHBhdGggdG8gdGhlXG4gKiBwcm9wZXJ0eSB3aGljaCB0cmlnZ2VyZWQgdGhlIGZhaWx1cmUuXG4gKi9cbnZhciBWRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWRXJyb3IocGF0aCwgbWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC93aWtpL0JyZWFraW5nLUNoYW5nZXMjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrIGZvciBpbmZvIGFib3V0IHRoaXMgd29ya2Fyb3VuZC5cbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBWRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVkVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5WRXJyb3IgPSBWRXJyb3I7XG4vKipcbiAqIEZhc3QgaW1wbGVtZW50YXRpb24gb2YgSUNvbnRleHQgdXNlZCBmb3IgZmlyc3QtcGFzcyB2YWxpZGF0aW9uLiBJZiB0aGF0IGZhaWxzLCB3ZSBjYW4gdmFsaWRhdGVcbiAqIHVzaW5nIERldGFpbENvbnRleHQgdG8gY29sbGVjdCBlcnJvciBtZXNzYWdlcy4gVGhhdCdzIGZhc3RlciBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZW4gbWVzc2FnZXNcbiAqIG5vcm1hbGx5IHBhc3MgdmFsaWRhdGlvbi5cbiAqL1xudmFyIE5vb3BDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vb3BDb250ZXh0KCkge1xuICAgIH1cbiAgICBOb29wQ29udGV4dC5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uIChyZWxQYXRoLCBtZXNzYWdlLCBzY29yZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBOb29wQ29udGV4dC5wcm90b3R5cGUudW5pb25SZXNvbHZlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgTm9vcENvbnRleHQucHJvdG90eXBlLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIE5vb3BDb250ZXh0LnByb3RvdHlwZS5yZXNvbHZlVW5pb24gPSBmdW5jdGlvbiAodXIpIHsgfTtcbiAgICByZXR1cm4gTm9vcENvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5Ob29wQ29udGV4dCA9IE5vb3BDb250ZXh0O1xuLyoqXG4gKiBDb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBJQ29udGV4dCB0aGF0IGNvbGxlY3RzIG1lYW5pbmdmdWxsIGVycm9ycy5cbiAqL1xudmFyIERldGFpbENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGV0YWlsQ29udGV4dCgpIHtcbiAgICAgICAgLy8gU3RhY2sgb2YgcHJvcGVydHkgbmFtZXMgYW5kIGFzc29jaWF0ZWQgbWVzc2FnZXMgZm9yIHJlcG9ydGluZyBoZWxwZnVsIGVycm9yIG1lc3NhZ2VzLlxuICAgICAgICB0aGlzLl9wcm9wTmFtZXMgPSBbXCJcIl07XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW251bGxdO1xuICAgICAgICAvLyBTY29yZSBpcyB1c2VkIHRvIGNob29zZSB0aGUgYmVzdCB1bmlvbiBtZW1iZXIgd2hvc2UgRGV0YWlsQ29udGV4dCB0byB1c2UgZm9yIHJlcG9ydGluZy5cbiAgICAgICAgLy8gSGlnaGVyIHNjb3JlIG1lYW5zIGJldHRlciBtYXRjaCAob3IgcmF0aGVyIGxlc3Mgc2V2ZXJlIG1pc21hdGNoKS5cbiAgICAgICAgdGhpcy5fc2NvcmUgPSAwO1xuICAgIH1cbiAgICBEZXRhaWxDb250ZXh0LnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKHJlbFBhdGgsIG1lc3NhZ2UsIHNjb3JlKSB7XG4gICAgICAgIHRoaXMuX3Byb3BOYW1lcy5wdXNoKHJlbFBhdGgpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9zY29yZSArPSBzY29yZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgRGV0YWlsQ29udGV4dC5wcm90b3R5cGUudW5pb25SZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXRhaWxVbmlvblJlc29sdmVyKCk7XG4gICAgfTtcbiAgICBEZXRhaWxDb250ZXh0LnByb3RvdHlwZS5yZXNvbHZlVW5pb24gPSBmdW5jdGlvbiAodW5pb25SZXNvbHZlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgdSA9IHVuaW9uUmVzb2x2ZXI7XG4gICAgICAgIHZhciBiZXN0ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYyA9IHUuY29udGV4dHM7IF9pIDwgX2MubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gX2NbX2ldO1xuICAgICAgICAgICAgaWYgKCFiZXN0IHx8IGN0eC5fc2NvcmUgPj0gYmVzdC5fc2NvcmUpIHtcbiAgICAgICAgICAgICAgICBiZXN0ID0gY3R4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZXN0ICYmIGJlc3QuX3Njb3JlID4gMCkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5fcHJvcE5hbWVzKS5wdXNoLmFwcGx5KF9hLCBiZXN0Ll9wcm9wTmFtZXMpO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5fbWVzc2FnZXMpLnB1c2guYXBwbHkoX2IsIGJlc3QuX21lc3NhZ2VzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGV0YWlsQ29udGV4dC5wcm90b3R5cGUuZ2V0RXJyb3IgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgbXNnUGFydHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX3Byb3BOYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLl9wcm9wTmFtZXNbaV07XG4gICAgICAgICAgICBwYXRoICs9ICh0eXBlb2YgcCA9PT0gXCJudW1iZXJcIikgPyBcIltcIiArIHAgKyBcIl1cIiA6IChwID8gXCIuXCIgKyBwIDogXCJcIik7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXMuX21lc3NhZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICBtc2dQYXJ0cy5wdXNoKHBhdGggKyBcIiBcIiArIG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVkVycm9yKHBhdGgsIG1zZ1BhcnRzLmpvaW4oXCI7IFwiKSk7XG4gICAgfTtcbiAgICBEZXRhaWxDb250ZXh0LnByb3RvdHlwZS5nZXRFcnJvckRldGFpbCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9wcm9wTmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5fcHJvcE5hbWVzW2ldO1xuICAgICAgICAgICAgcGF0aCArPSAodHlwZW9mIHAgPT09IFwibnVtYmVyXCIpID8gXCJbXCIgKyBwICsgXCJdXCIgOiAocCA/IFwiLlwiICsgcCA6IFwiXCIpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9tZXNzYWdlc1tpXTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKHsgcGF0aDogcGF0aCwgbWVzc2FnZTogbWVzc2FnZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZGV0YWlsID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGRldGFpbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChkZXRhaWwpIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzW2ldLm5lc3RlZCA9IFtkZXRhaWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0YWlsID0gZGV0YWlsc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGV0YWlsO1xuICAgIH07XG4gICAgcmV0dXJuIERldGFpbENvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5EZXRhaWxDb250ZXh0ID0gRGV0YWlsQ29udGV4dDtcbnZhciBEZXRhaWxVbmlvblJlc29sdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERldGFpbFVuaW9uUmVzb2x2ZXIoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dHMgPSBbXTtcbiAgICB9XG4gICAgRGV0YWlsVW5pb25SZXNvbHZlci5wcm90b3R5cGUuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN0eCA9IG5ldyBEZXRhaWxDb250ZXh0KCk7XG4gICAgICAgIHRoaXMuY29udGV4dHMucHVzaChjdHgpO1xuICAgICAgICByZXR1cm4gY3R4O1xuICAgIH07XG4gICAgcmV0dXJuIERldGFpbFVuaW9uUmVzb2x2ZXI7XG59KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/ts-interface-checker@0.1.13/node_modules/ts-interface-checker/dist/util.js\n");

/***/ })

};
;