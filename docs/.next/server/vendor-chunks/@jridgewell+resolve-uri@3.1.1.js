"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@jridgewell+resolve-uri@3.1.1";
exports.ids = ["vendor-chunks/@jridgewell+resolve-uri@3.1.1"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@jridgewell+resolve-uri@3.1.1/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs":
/*!*********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@jridgewell+resolve-uri@3.1.1/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ resolve)\n/* harmony export */ });\n// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\nvar UrlType;\n(function (UrlType) {\n    UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n    UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n    UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n    UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n    UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n    UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n    UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n})(UrlType || (UrlType = {}));\nfunction isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n}\nfunction isAbsolutePath(input) {\n    return input.startsWith('/');\n}\nfunction isFileUrl(input) {\n    return input.startsWith('file:');\n}\nfunction isRelative(input) {\n    return /^[.?#]/.test(input);\n}\nfunction parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n}\nfunction parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n}\nfunction makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n        scheme,\n        user,\n        host,\n        port,\n        path,\n        query,\n        hash,\n        type: UrlType.Absolute,\n    };\n}\nfunction parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n        const url = parseAbsoluteUrl('http:' + input);\n        url.scheme = '';\n        url.type = UrlType.SchemeRelative;\n        return url;\n    }\n    if (isAbsolutePath(input)) {\n        const url = parseAbsoluteUrl('http://foo.com' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = UrlType.AbsolutePath;\n        return url;\n    }\n    if (isFileUrl(input))\n        return parseFileUrl(input);\n    if (isAbsoluteUrl(input))\n        return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input\n        ? input.startsWith('?')\n            ? UrlType.Query\n            : input.startsWith('#')\n                ? UrlType.Hash\n                : UrlType.RelativePath\n        : UrlType.Empty;\n    return url;\n}\nfunction stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..'))\n        return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n    normalizePath(base, base.type);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n        url.path = base.path;\n    }\n    else {\n        // Resolution happens relative to the base path's directory, not the file.\n        url.path = stripPathFilename(base.path) + url.path;\n    }\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url, type) {\n    const rel = type <= UrlType.RelativePath;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n        const piece = pieces[i];\n        // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n        if (!piece) {\n            addTrailingSlash = true;\n            continue;\n        }\n        // If we encounter a real directory, then we don't need to append anymore.\n        addTrailingSlash = false;\n        // A current directory, which we can always drop.\n        if (piece === '.')\n            continue;\n        // A parent directory, we need to see if there are any real directories we can pop. Else, we\n        // have an excess of parents, and we'll need to keep the \"..\".\n        if (piece === '..') {\n            if (positive) {\n                addTrailingSlash = true;\n                positive--;\n                pointer--;\n            }\n            else if (rel) {\n                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                pieces[pointer++] = piece;\n            }\n            continue;\n        }\n        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n        // any popped or dropped directories.\n        pieces[pointer++] = piece;\n        positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n        path += '/' + pieces[i];\n    }\n    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n        path += '/';\n    }\n    url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nfunction resolve(input, base) {\n    if (!input && !base)\n        return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== UrlType.Absolute) {\n        const baseUrl = parseUrl(base);\n        const baseType = baseUrl.type;\n        switch (inputType) {\n            case UrlType.Empty:\n                url.hash = baseUrl.hash;\n            // fall through\n            case UrlType.Hash:\n                url.query = baseUrl.query;\n            // fall through\n            case UrlType.Query:\n            case UrlType.RelativePath:\n                mergePaths(url, baseUrl);\n            // fall through\n            case UrlType.AbsolutePath:\n                // The host, user, and port are joined, you can't copy one without the others.\n                url.user = baseUrl.user;\n                url.host = baseUrl.host;\n                url.port = baseUrl.port;\n            // fall through\n            case UrlType.SchemeRelative:\n                // The input doesn't have a schema at least, so we need to copy at least that over.\n                url.scheme = baseUrl.scheme;\n        }\n        if (baseType > inputType)\n            inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch (inputType) {\n        // This is impossible, because of the empty checks at the start of the function.\n        // case UrlType.Empty:\n        case UrlType.Hash:\n        case UrlType.Query:\n            return queryHash;\n        case UrlType.RelativePath: {\n            // The first char is always a \"/\", and we need it to be relative.\n            const path = url.path.slice(1);\n            if (!path)\n                return queryHash || '.';\n            if (isRelative(base || input) && !isRelative(path)) {\n                // If base started with a leading \".\", or there is no base and input started with a \".\",\n                // then we need to ensure that the relative path starts with a \".\". We don't know if\n                // relative starts with a \"..\", though, so check before prepending.\n                return './' + path + queryHash;\n            }\n            return path + queryHash;\n        }\n        case UrlType.AbsolutePath:\n            return url.path + queryHash;\n        default:\n            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n}\n\n\n//# sourceMappingURL=resolve-uri.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqcmlkZ2V3ZWxsK3Jlc29sdmUtdXJpQDMuMS4xL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC9yZXNvbHZlLXVyaS9kaXN0L3Jlc29sdmUtdXJpLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4QjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2RvY3MvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqcmlkZ2V3ZWxsK3Jlc29sdmUtdXJpQDMuMS4xL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC9yZXNvbHZlLXVyaS9kaXN0L3Jlc29sdmUtdXJpLm1qcz9iY2EyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1hdGNoZXMgdGhlIHNjaGVtZSBvZiBhIFVSTCwgZWcgXCJodHRwOi8vXCJcbmNvbnN0IHNjaGVtZVJlZ2V4ID0gL15bXFx3Ky4tXSs6XFwvXFwvLztcbi8qKlxuICogTWF0Y2hlcyB0aGUgcGFydHMgb2YgYSBVUkw6XG4gKiAxLiBTY2hlbWUsIGluY2x1ZGluZyBcIjpcIiwgZ3VhcmFudGVlZC5cbiAqIDIuIFVzZXIvcGFzc3dvcmQsIGluY2x1ZGluZyBcIkBcIiwgb3B0aW9uYWwuXG4gKiAzLiBIb3N0LCBndWFyYW50ZWVkLlxuICogNC4gUG9ydCwgaW5jbHVkaW5nIFwiOlwiLCBvcHRpb25hbC5cbiAqIDUuIFBhdGgsIGluY2x1ZGluZyBcIi9cIiwgb3B0aW9uYWwuXG4gKiA2LiBRdWVyeSwgaW5jbHVkaW5nIFwiP1wiLCBvcHRpb25hbC5cbiAqIDcuIEhhc2gsIGluY2x1ZGluZyBcIiNcIiwgb3B0aW9uYWwuXG4gKi9cbmNvbnN0IHVybFJlZ2V4ID0gL14oW1xcdysuLV0rOilcXC9cXC8oW15ALyM/XSpAKT8oW146LyM/XSopKDpcXGQrKT8oXFwvW14jP10qKT8oXFw/W14jXSopPygjLiopPy87XG4vKipcbiAqIEZpbGUgVVJMcyBhcmUgd2VpcmQuIFRoZXkgZG9udCcgbmVlZCB0aGUgcmVndWxhciBgLy9gIGluIHRoZSBzY2hlbWUsIHRoZXkgbWF5IG9yIG1heSBub3Qgc3RhcnRcbiAqIHdpdGggYSBsZWFkaW5nIGAvYCwgdGhleSBjYW4gaGF2ZSBhIGRvbWFpbiAoYnV0IG9ubHkgaWYgdGhleSBkb24ndCBzdGFydCB3aXRoIGEgV2luZG93cyBkcml2ZSkuXG4gKlxuICogMS4gSG9zdCwgb3B0aW9uYWwuXG4gKiAyLiBQYXRoLCB3aGljaCBtYXkgaW5jbHVkZSBcIi9cIiwgZ3VhcmFudGVlZC5cbiAqIDMuIFF1ZXJ5LCBpbmNsdWRpbmcgXCI/XCIsIG9wdGlvbmFsLlxuICogNC4gSGFzaCwgaW5jbHVkaW5nIFwiI1wiLCBvcHRpb25hbC5cbiAqL1xuY29uc3QgZmlsZVJlZ2V4ID0gL15maWxlOig/OlxcL1xcLygoPyFbYS16XTopW14vIz9dKik/KT8oXFwvP1teIz9dKikoXFw/W14jXSopPygjLiopPy9pO1xudmFyIFVybFR5cGU7XG4oZnVuY3Rpb24gKFVybFR5cGUpIHtcbiAgICBVcmxUeXBlW1VybFR5cGVbXCJFbXB0eVwiXSA9IDFdID0gXCJFbXB0eVwiO1xuICAgIFVybFR5cGVbVXJsVHlwZVtcIkhhc2hcIl0gPSAyXSA9IFwiSGFzaFwiO1xuICAgIFVybFR5cGVbVXJsVHlwZVtcIlF1ZXJ5XCJdID0gM10gPSBcIlF1ZXJ5XCI7XG4gICAgVXJsVHlwZVtVcmxUeXBlW1wiUmVsYXRpdmVQYXRoXCJdID0gNF0gPSBcIlJlbGF0aXZlUGF0aFwiO1xuICAgIFVybFR5cGVbVXJsVHlwZVtcIkFic29sdXRlUGF0aFwiXSA9IDVdID0gXCJBYnNvbHV0ZVBhdGhcIjtcbiAgICBVcmxUeXBlW1VybFR5cGVbXCJTY2hlbWVSZWxhdGl2ZVwiXSA9IDZdID0gXCJTY2hlbWVSZWxhdGl2ZVwiO1xuICAgIFVybFR5cGVbVXJsVHlwZVtcIkFic29sdXRlXCJdID0gN10gPSBcIkFic29sdXRlXCI7XG59KShVcmxUeXBlIHx8IChVcmxUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGlzQWJzb2x1dGVVcmwoaW5wdXQpIHtcbiAgICByZXR1cm4gc2NoZW1lUmVnZXgudGVzdChpbnB1dCk7XG59XG5mdW5jdGlvbiBpc1NjaGVtZVJlbGF0aXZlVXJsKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnN0YXJ0c1dpdGgoJy8vJyk7XG59XG5mdW5jdGlvbiBpc0Fic29sdXRlUGF0aChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5zdGFydHNXaXRoKCcvJyk7XG59XG5mdW5jdGlvbiBpc0ZpbGVVcmwoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQuc3RhcnRzV2l0aCgnZmlsZTonKTtcbn1cbmZ1bmN0aW9uIGlzUmVsYXRpdmUoaW5wdXQpIHtcbiAgICByZXR1cm4gL15bLj8jXS8udGVzdChpbnB1dCk7XG59XG5mdW5jdGlvbiBwYXJzZUFic29sdXRlVXJsKGlucHV0KSB7XG4gICAgY29uc3QgbWF0Y2ggPSB1cmxSZWdleC5leGVjKGlucHV0KTtcbiAgICByZXR1cm4gbWFrZVVybChtYXRjaFsxXSwgbWF0Y2hbMl0gfHwgJycsIG1hdGNoWzNdLCBtYXRjaFs0XSB8fCAnJywgbWF0Y2hbNV0gfHwgJy8nLCBtYXRjaFs2XSB8fCAnJywgbWF0Y2hbN10gfHwgJycpO1xufVxuZnVuY3Rpb24gcGFyc2VGaWxlVXJsKGlucHV0KSB7XG4gICAgY29uc3QgbWF0Y2ggPSBmaWxlUmVnZXguZXhlYyhpbnB1dCk7XG4gICAgY29uc3QgcGF0aCA9IG1hdGNoWzJdO1xuICAgIHJldHVybiBtYWtlVXJsKCdmaWxlOicsICcnLCBtYXRjaFsxXSB8fCAnJywgJycsIGlzQWJzb2x1dGVQYXRoKHBhdGgpID8gcGF0aCA6ICcvJyArIHBhdGgsIG1hdGNoWzNdIHx8ICcnLCBtYXRjaFs0XSB8fCAnJyk7XG59XG5mdW5jdGlvbiBtYWtlVXJsKHNjaGVtZSwgdXNlciwgaG9zdCwgcG9ydCwgcGF0aCwgcXVlcnksIGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWUsXG4gICAgICAgIHVzZXIsXG4gICAgICAgIGhvc3QsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBoYXNoLFxuICAgICAgICB0eXBlOiBVcmxUeXBlLkFic29sdXRlLFxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZVVybChpbnB1dCkge1xuICAgIGlmIChpc1NjaGVtZVJlbGF0aXZlVXJsKGlucHV0KSkge1xuICAgICAgICBjb25zdCB1cmwgPSBwYXJzZUFic29sdXRlVXJsKCdodHRwOicgKyBpbnB1dCk7XG4gICAgICAgIHVybC5zY2hlbWUgPSAnJztcbiAgICAgICAgdXJsLnR5cGUgPSBVcmxUeXBlLlNjaGVtZVJlbGF0aXZlO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBpZiAoaXNBYnNvbHV0ZVBhdGgoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHBhcnNlQWJzb2x1dGVVcmwoJ2h0dHA6Ly9mb28uY29tJyArIGlucHV0KTtcbiAgICAgICAgdXJsLnNjaGVtZSA9ICcnO1xuICAgICAgICB1cmwuaG9zdCA9ICcnO1xuICAgICAgICB1cmwudHlwZSA9IFVybFR5cGUuQWJzb2x1dGVQYXRoO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBpZiAoaXNGaWxlVXJsKGlucHV0KSlcbiAgICAgICAgcmV0dXJuIHBhcnNlRmlsZVVybChpbnB1dCk7XG4gICAgaWYgKGlzQWJzb2x1dGVVcmwoaW5wdXQpKVxuICAgICAgICByZXR1cm4gcGFyc2VBYnNvbHV0ZVVybChpbnB1dCk7XG4gICAgY29uc3QgdXJsID0gcGFyc2VBYnNvbHV0ZVVybCgnaHR0cDovL2Zvby5jb20vJyArIGlucHV0KTtcbiAgICB1cmwuc2NoZW1lID0gJyc7XG4gICAgdXJsLmhvc3QgPSAnJztcbiAgICB1cmwudHlwZSA9IGlucHV0XG4gICAgICAgID8gaW5wdXQuc3RhcnRzV2l0aCgnPycpXG4gICAgICAgICAgICA/IFVybFR5cGUuUXVlcnlcbiAgICAgICAgICAgIDogaW5wdXQuc3RhcnRzV2l0aCgnIycpXG4gICAgICAgICAgICAgICAgPyBVcmxUeXBlLkhhc2hcbiAgICAgICAgICAgICAgICA6IFVybFR5cGUuUmVsYXRpdmVQYXRoXG4gICAgICAgIDogVXJsVHlwZS5FbXB0eTtcbiAgICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gc3RyaXBQYXRoRmlsZW5hbWUocGF0aCkge1xuICAgIC8vIElmIGEgcGF0aCBlbmRzIHdpdGggYSBwYXJlbnQgZGlyZWN0b3J5IFwiLi5cIiwgdGhlbiBpdCdzIGEgcmVsYXRpdmUgcGF0aCB3aXRoIGV4Y2VzcyBwYXJlbnRcbiAgICAvLyBwYXRocy4gSXQncyBub3QgYSBmaWxlLCBzbyB3ZSBjYW4ndCBzdHJpcCBpdC5cbiAgICBpZiAocGF0aC5lbmRzV2l0aCgnLy4uJykpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIGNvbnN0IGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGluZGV4ICsgMSk7XG59XG5mdW5jdGlvbiBtZXJnZVBhdGhzKHVybCwgYmFzZSkge1xuICAgIG5vcm1hbGl6ZVBhdGgoYmFzZSwgYmFzZS50eXBlKTtcbiAgICAvLyBJZiB0aGUgcGF0aCBpcyBqdXN0IGEgXCIvXCIsIHRoZW4gaXQgd2FzIGFuIGVtcHR5IHBhdGggdG8gYmVnaW4gd2l0aCAocmVtZW1iZXIsIHdlJ3JlIGEgcmVsYXRpdmVcbiAgICAvLyBwYXRoKS5cbiAgICBpZiAodXJsLnBhdGggPT09ICcvJykge1xuICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFJlc29sdXRpb24gaGFwcGVucyByZWxhdGl2ZSB0byB0aGUgYmFzZSBwYXRoJ3MgZGlyZWN0b3J5LCBub3QgdGhlIGZpbGUuXG4gICAgICAgIHVybC5wYXRoID0gc3RyaXBQYXRoRmlsZW5hbWUoYmFzZS5wYXRoKSArIHVybC5wYXRoO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHBhdGggY2FuIGhhdmUgZW1wdHkgZGlyZWN0b3JpZXMgXCIvL1wiLCB1bm5lZWRlZCBwYXJlbnRzIFwiZm9vLy4uXCIsIG9yIGN1cnJlbnQgZGlyZWN0b3J5XG4gKiBcImZvby8uXCIuIFdlIG5lZWQgdG8gbm9ybWFsaXplIHRvIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgodXJsLCB0eXBlKSB7XG4gICAgY29uc3QgcmVsID0gdHlwZSA8PSBVcmxUeXBlLlJlbGF0aXZlUGF0aDtcbiAgICBjb25zdCBwaWVjZXMgPSB1cmwucGF0aC5zcGxpdCgnLycpO1xuICAgIC8vIFdlIG5lZWQgdG8gcHJlc2VydmUgdGhlIGZpcnN0IHBpZWNlIGFsd2F5cywgc28gdGhhdCB3ZSBvdXRwdXQgYSBsZWFkaW5nIHNsYXNoLiBUaGUgaXRlbSBhdFxuICAgIC8vIHBpZWNlc1swXSBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgbGV0IHBvaW50ZXIgPSAxO1xuICAgIC8vIFBvc2l0aXZlIGlzIHRoZSBudW1iZXIgb2YgcmVhbCBkaXJlY3RvcmllcyB3ZSd2ZSBvdXRwdXQsIHVzZWQgZm9yIHBvcHBpbmcgYSBwYXJlbnQgZGlyZWN0b3J5LlxuICAgIC8vIEVnLCBcImZvby9iYXIvLi5cIiB3aWxsIGhhdmUgYSBwb3NpdGl2ZSAyLCBhbmQgd2UgY2FuIGRlY3JlbWVudCB0byBiZSBsZWZ0IHdpdGgganVzdCBcImZvb1wiLlxuICAgIGxldCBwb3NpdGl2ZSA9IDA7XG4gICAgLy8gV2UgbmVlZCB0byBrZWVwIGEgdHJhaWxpbmcgc2xhc2ggaWYgd2UgZW5jb3VudGVyIGFuIGVtcHR5IGRpcmVjdG9yeSAoZWcsIHNwbGl0dGluZyBcImZvby9cIiB3aWxsXG4gICAgLy8gZ2VuZXJhdGUgYFtcImZvb1wiLCBcIlwiXWAgcGllY2VzKS4gQW5kLCBpZiB3ZSBwb3AgYSBwYXJlbnQgZGlyZWN0b3J5LiBCdXQgb25jZSB3ZSBlbmNvdW50ZXIgYVxuICAgIC8vIHJlYWwgZGlyZWN0b3J5LCB3ZSB3b24ndCBuZWVkIHRvIGFwcGVuZCwgdW5sZXNzIHRoZSBvdGhlciBjb25kaXRpb25zIGhhcHBlbiBhZ2Fpbi5cbiAgICBsZXQgYWRkVHJhaWxpbmdTbGFzaCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBpZWNlID0gcGllY2VzW2ldO1xuICAgICAgICAvLyBBbiBlbXB0eSBkaXJlY3RvcnksIGNvdWxkIGJlIGEgdHJhaWxpbmcgc2xhc2gsIG9yIGp1c3QgYSBkb3VibGUgXCIvL1wiIGluIHRoZSBwYXRoLlxuICAgICAgICBpZiAoIXBpZWNlKSB7XG4gICAgICAgICAgICBhZGRUcmFpbGluZ1NsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhIHJlYWwgZGlyZWN0b3J5LCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gYXBwZW5kIGFueW1vcmUuXG4gICAgICAgIGFkZFRyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgLy8gQSBjdXJyZW50IGRpcmVjdG9yeSwgd2hpY2ggd2UgY2FuIGFsd2F5cyBkcm9wLlxuICAgICAgICBpZiAocGllY2UgPT09ICcuJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyBBIHBhcmVudCBkaXJlY3RvcnksIHdlIG5lZWQgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgcmVhbCBkaXJlY3RvcmllcyB3ZSBjYW4gcG9wLiBFbHNlLCB3ZVxuICAgICAgICAvLyBoYXZlIGFuIGV4Y2VzcyBvZiBwYXJlbnRzLCBhbmQgd2UnbGwgbmVlZCB0byBrZWVwIHRoZSBcIi4uXCIuXG4gICAgICAgIGlmIChwaWVjZSA9PT0gJy4uJykge1xuICAgICAgICAgICAgaWYgKHBvc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgYWRkVHJhaWxpbmdTbGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcG9zaXRpdmUtLTtcbiAgICAgICAgICAgICAgICBwb2ludGVyLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIHJlbGF0aXZlUGF0aCwgdGhlbiB3ZSBuZWVkIHRvIGtlZXAgdGhlIGV4Y2VzcyBwYXJlbnRzLiBFbHNlLCBpbiBhbiBhYnNvbHV0ZVxuICAgICAgICAgICAgICAgIC8vIFVSTCwgcHJvdG9jb2wgcmVsYXRpdmUgVVJMLCBvciBhbiBhYnNvbHV0ZSBwYXRoLCB3ZSBkb24ndCBuZWVkIHRvIGtlZXAgZXhjZXNzLlxuICAgICAgICAgICAgICAgIHBpZWNlc1twb2ludGVyKytdID0gcGllY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSd2ZSBlbmNvdW50ZXJlZCBhIHJlYWwgZGlyZWN0b3J5LiBNb3ZlIGl0IHRvIHRoZSBuZXh0IGluc2VydGlvbiBwb2ludGVyLCB3aGljaCBhY2NvdW50cyBmb3JcbiAgICAgICAgLy8gYW55IHBvcHBlZCBvciBkcm9wcGVkIGRpcmVjdG9yaWVzLlxuICAgICAgICBwaWVjZXNbcG9pbnRlcisrXSA9IHBpZWNlO1xuICAgICAgICBwb3NpdGl2ZSsrO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRlcjsgaSsrKSB7XG4gICAgICAgIHBhdGggKz0gJy8nICsgcGllY2VzW2ldO1xuICAgIH1cbiAgICBpZiAoIXBhdGggfHwgKGFkZFRyYWlsaW5nU2xhc2ggJiYgIXBhdGguZW5kc1dpdGgoJy8uLicpKSkge1xuICAgICAgICBwYXRoICs9ICcvJztcbiAgICB9XG4gICAgdXJsLnBhdGggPSBwYXRoO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXNvbHZlIGBpbnB1dGAgVVJML3BhdGggcmVsYXRpdmUgdG8gYGJhc2VgLlxuICovXG5mdW5jdGlvbiByZXNvbHZlKGlucHV0LCBiYXNlKSB7XG4gICAgaWYgKCFpbnB1dCAmJiAhYmFzZSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IHVybCA9IHBhcnNlVXJsKGlucHV0KTtcbiAgICBsZXQgaW5wdXRUeXBlID0gdXJsLnR5cGU7XG4gICAgaWYgKGJhc2UgJiYgaW5wdXRUeXBlICE9PSBVcmxUeXBlLkFic29sdXRlKSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBwYXJzZVVybChiYXNlKTtcbiAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBiYXNlVXJsLnR5cGU7XG4gICAgICAgIHN3aXRjaCAoaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFVybFR5cGUuRW1wdHk6XG4gICAgICAgICAgICAgICAgdXJsLmhhc2ggPSBiYXNlVXJsLmhhc2g7XG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgVXJsVHlwZS5IYXNoOlxuICAgICAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2VVcmwucXVlcnk7XG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgVXJsVHlwZS5RdWVyeTpcbiAgICAgICAgICAgIGNhc2UgVXJsVHlwZS5SZWxhdGl2ZVBhdGg6XG4gICAgICAgICAgICAgICAgbWVyZ2VQYXRocyh1cmwsIGJhc2VVcmwpO1xuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIFVybFR5cGUuQWJzb2x1dGVQYXRoOlxuICAgICAgICAgICAgICAgIC8vIFRoZSBob3N0LCB1c2VyLCBhbmQgcG9ydCBhcmUgam9pbmVkLCB5b3UgY2FuJ3QgY29weSBvbmUgd2l0aG91dCB0aGUgb3RoZXJzLlxuICAgICAgICAgICAgICAgIHVybC51c2VyID0gYmFzZVVybC51c2VyO1xuICAgICAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZVVybC5ob3N0O1xuICAgICAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZVVybC5wb3J0O1xuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIFVybFR5cGUuU2NoZW1lUmVsYXRpdmU6XG4gICAgICAgICAgICAgICAgLy8gVGhlIGlucHV0IGRvZXNuJ3QgaGF2ZSBhIHNjaGVtYSBhdCBsZWFzdCwgc28gd2UgbmVlZCB0byBjb3B5IGF0IGxlYXN0IHRoYXQgb3Zlci5cbiAgICAgICAgICAgICAgICB1cmwuc2NoZW1lID0gYmFzZVVybC5zY2hlbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID4gaW5wdXRUeXBlKVxuICAgICAgICAgICAgaW5wdXRUeXBlID0gYmFzZVR5cGU7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVBhdGgodXJsLCBpbnB1dFR5cGUpO1xuICAgIGNvbnN0IHF1ZXJ5SGFzaCA9IHVybC5xdWVyeSArIHVybC5oYXNoO1xuICAgIHN3aXRjaCAoaW5wdXRUeXBlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW1wb3NzaWJsZSwgYmVjYXVzZSBvZiB0aGUgZW1wdHkgY2hlY2tzIGF0IHRoZSBzdGFydCBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgIC8vIGNhc2UgVXJsVHlwZS5FbXB0eTpcbiAgICAgICAgY2FzZSBVcmxUeXBlLkhhc2g6XG4gICAgICAgIGNhc2UgVXJsVHlwZS5RdWVyeTpcbiAgICAgICAgICAgIHJldHVybiBxdWVyeUhhc2g7XG4gICAgICAgIGNhc2UgVXJsVHlwZS5SZWxhdGl2ZVBhdGg6IHtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBjaGFyIGlzIGFsd2F5cyBhIFwiL1wiLCBhbmQgd2UgbmVlZCBpdCB0byBiZSByZWxhdGl2ZS5cbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSB1cmwucGF0aC5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmICghcGF0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlIYXNoIHx8ICcuJztcbiAgICAgICAgICAgIGlmIChpc1JlbGF0aXZlKGJhc2UgfHwgaW5wdXQpICYmICFpc1JlbGF0aXZlKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYmFzZSBzdGFydGVkIHdpdGggYSBsZWFkaW5nIFwiLlwiLCBvciB0aGVyZSBpcyBubyBiYXNlIGFuZCBpbnB1dCBzdGFydGVkIHdpdGggYSBcIi5cIixcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHJlbGF0aXZlIHBhdGggc3RhcnRzIHdpdGggYSBcIi5cIi4gV2UgZG9uJ3Qga25vdyBpZlxuICAgICAgICAgICAgICAgIC8vIHJlbGF0aXZlIHN0YXJ0cyB3aXRoIGEgXCIuLlwiLCB0aG91Z2gsIHNvIGNoZWNrIGJlZm9yZSBwcmVwZW5kaW5nLlxuICAgICAgICAgICAgICAgIHJldHVybiAnLi8nICsgcGF0aCArIHF1ZXJ5SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoICsgcXVlcnlIYXNoO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgVXJsVHlwZS5BYnNvbHV0ZVBhdGg6XG4gICAgICAgICAgICByZXR1cm4gdXJsLnBhdGggKyBxdWVyeUhhc2g7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdXJsLnNjaGVtZSArICcvLycgKyB1cmwudXNlciArIHVybC5ob3N0ICsgdXJsLnBvcnQgKyB1cmwucGF0aCArIHF1ZXJ5SGFzaDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IHJlc29sdmUgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS11cmkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@jridgewell+resolve-uri@3.1.1/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs\n");

/***/ })

};
;