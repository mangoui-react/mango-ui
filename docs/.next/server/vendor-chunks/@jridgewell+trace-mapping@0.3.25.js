"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@jridgewell+trace-mapping@0.3.25";
exports.ids = ["vendor-chunks/@jridgewell+trace-mapping@0.3.25"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs":
/*!****************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnyMap: () => (/* binding */ AnyMap),\n/* harmony export */   GREATEST_LOWER_BOUND: () => (/* binding */ GREATEST_LOWER_BOUND),\n/* harmony export */   LEAST_UPPER_BOUND: () => (/* binding */ LEAST_UPPER_BOUND),\n/* harmony export */   TraceMap: () => (/* binding */ TraceMap),\n/* harmony export */   allGeneratedPositionsFor: () => (/* binding */ allGeneratedPositionsFor),\n/* harmony export */   decodedMap: () => (/* binding */ decodedMap),\n/* harmony export */   decodedMappings: () => (/* binding */ decodedMappings),\n/* harmony export */   eachMapping: () => (/* binding */ eachMapping),\n/* harmony export */   encodedMap: () => (/* binding */ encodedMap),\n/* harmony export */   encodedMappings: () => (/* binding */ encodedMappings),\n/* harmony export */   generatedPositionFor: () => (/* binding */ generatedPositionFor),\n/* harmony export */   isIgnored: () => (/* binding */ isIgnored),\n/* harmony export */   originalPositionFor: () => (/* binding */ originalPositionFor),\n/* harmony export */   presortedDecodedMap: () => (/* binding */ presortedDecodedMap),\n/* harmony export */   sourceContentFor: () => (/* binding */ sourceContentFor),\n/* harmony export */   traceSegment: () => (/* binding */ traceSegment)\n/* harmony export */ });\n/* harmony import */ var _jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jridgewell/sourcemap-codec */ \"(ssr)/../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.15/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\");\n/* harmony import */ var _jridgewell_resolve_uri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jridgewell/resolve-uri */ \"(ssr)/../node_modules/.pnpm/@jridgewell+resolve-uri@3.1.1/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs\");\n\n\n\nfunction resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/'))\n        base += '/';\n    return (0,_jridgewell_resolve_uri__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, base);\n}\n\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nfunction stripFilename(path) {\n    if (!path)\n        return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst REV_GENERATED_LINE = 1;\nconst REV_GENERATED_COLUMN = 2;\n\nfunction maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length)\n        return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned)\n        mappings = mappings.slice();\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n        mappings[i] = sortSegments(mappings[i], owned);\n    }\n    return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n        if (!isSorted(mappings[i]))\n            return i;\n    }\n    return mappings.length;\n}\nfunction isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n        if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction sortSegments(line, owned) {\n    if (!owned)\n        line = line.slice();\n    return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n}\n\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nfunction binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n        const mid = low + ((high - low) >> 1);\n        const cmp = haystack[mid][COLUMN] - needle;\n        if (cmp === 0) {\n            found = true;\n            return mid;\n        }\n        if (cmp < 0) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    found = false;\n    return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; index = i++) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; index = i--) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction memoizedState() {\n    return {\n        lastKey: -1,\n        lastNeedle: -1,\n        lastIndex: -1,\n    };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n    const { lastKey, lastNeedle, lastIndex } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n    if (key === lastKey) {\n        if (needle === lastNeedle) {\n            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n            return lastIndex;\n        }\n        if (needle >= lastNeedle) {\n            // lastIndex may be -1 if the previous needle was not found.\n            low = lastIndex === -1 ? 0 : lastIndex;\n        }\n        else {\n            high = lastIndex;\n        }\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nfunction buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            if (seg.length === 1)\n                continue;\n            const sourceIndex = seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            const originalSource = sources[sourceIndex];\n            const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n            const memo = memos[sourceIndex];\n            // The binary search either found a match, or it found the left-index just before where the\n            // segment should go. Either way, we want to insert after that. And there may be multiple\n            // generated segments associated with an original location, so there may need to move several\n            // indexes before we find where we need to insert.\n            let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n            memo.lastIndex = ++index;\n            insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n        }\n    }\n    return sources;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray() {\n    return { __proto__: null };\n}\n\nconst AnyMap = function (map, mapUrl) {\n    const parsed = parse(map);\n    if (!('sections' in parsed)) {\n        return new TraceMap(parsed, mapUrl);\n    }\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    const ignoreList = [];\n    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);\n    const joined = {\n        version: 3,\n        file: parsed.file,\n        names,\n        sources,\n        sourcesContent,\n        mappings,\n        ignoreList,\n    };\n    return presortedDecodedMap(joined);\n};\nfunction parse(map) {\n    return typeof map === 'string' ? JSON.parse(map) : map;\n}\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n    const { sections } = input;\n    for (let i = 0; i < sections.length; i++) {\n        const { map, offset } = sections[i];\n        let sl = stopLine;\n        let sc = stopColumn;\n        if (i + 1 < sections.length) {\n            const nextOffset = sections[i + 1].offset;\n            sl = Math.min(stopLine, lineOffset + nextOffset.line);\n            if (sl === stopLine) {\n                sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n            }\n            else if (sl < stopLine) {\n                sc = columnOffset + nextOffset.column;\n            }\n        }\n        addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n    }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n    const parsed = parse(input);\n    if ('sections' in parsed)\n        return recurse(...arguments);\n    const map = new TraceMap(parsed, mapUrl);\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = decodedMappings(map);\n    const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n    append(sources, resolvedSources);\n    append(names, map.names);\n    if (contents)\n        append(sourcesContent, contents);\n    else\n        for (let i = 0; i < resolvedSources.length; i++)\n            sourcesContent.push(null);\n    if (ignores)\n        for (let i = 0; i < ignores.length; i++)\n            ignoreList.push(ignores[i] + sourcesOffset);\n    for (let i = 0; i < decoded.length; i++) {\n        const lineI = lineOffset + i;\n        // We can only add so many lines before we step into the range that the next section's map\n        // controls. When we get to the last line, then we'll start checking the segments to see if\n        // they've crossed into the column range. But it may not have any columns that overstep, so we\n        // still need to check that we don't overstep lines, too.\n        if (lineI > stopLine)\n            return;\n        // The out line may already exist in mappings (if we're continuing the line started by a\n        // previous section). Or, we may have jumped ahead several lines to start this section.\n        const out = getLine(mappings, lineI);\n        // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n        // map can be multiple lines), it doesn't.\n        const cOffset = i === 0 ? columnOffset : 0;\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            const column = cOffset + seg[COLUMN];\n            // If this segment steps into the column range that the next section's map controls, we need\n            // to stop early.\n            if (lineI === stopLine && column >= stopColumn)\n                return;\n            if (seg.length === 1) {\n                out.push([column]);\n                continue;\n            }\n            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            out.push(seg.length === 4\n                ? [column, sourcesIndex, sourceLine, sourceColumn]\n                : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n        }\n    }\n}\nfunction append(arr, other) {\n    for (let i = 0; i < other.length; i++)\n        arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n    for (let i = arr.length; i <= index; i++)\n        arr[i] = [];\n    return arr[index];\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\nclass TraceMap {\n    constructor(map, mapUrl) {\n        const isString = typeof map === 'string';\n        if (!isString && map._decodedMemo)\n            return map;\n        const parsed = (isString ? JSON.parse(map) : map);\n        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n        this.version = version;\n        this.file = file;\n        this.names = names || [];\n        this.sourceRoot = sourceRoot;\n        this.sources = sources;\n        this.sourcesContent = sourcesContent;\n        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;\n        const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n        this.resolvedSources = sources.map((s) => resolve(s || '', from));\n        const { mappings } = parsed;\n        if (typeof mappings === 'string') {\n            this._encoded = mappings;\n            this._decoded = undefined;\n        }\n        else {\n            this._encoded = undefined;\n            this._decoded = maybeSort(mappings, isString);\n        }\n        this._decodedMemo = memoizedState();\n        this._bySources = undefined;\n        this._bySourceMemos = undefined;\n    }\n}\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map) {\n    return map;\n}\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nfunction encodedMappings(map) {\n    var _a;\n    var _b;\n    return ((_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : (_b._encoded = (0,_jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__.encode)(cast(map)._decoded)));\n}\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nfunction decodedMappings(map) {\n    var _a;\n    return ((_a = cast(map))._decoded || (_a._decoded = (0,_jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__.decode)(cast(map)._encoded)));\n}\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nfunction traceSegment(map, line, column) {\n    const decoded = decodedMappings(map);\n    // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n    if (line >= decoded.length)\n        return null;\n    const segments = decoded[line];\n    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n    return index === -1 ? null : segments[index];\n}\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nfunction originalPositionFor(map, needle) {\n    let { line, column, bias } = needle;\n    line--;\n    if (line < 0)\n        throw new Error(LINE_GTR_ZERO);\n    if (column < 0)\n        throw new Error(COL_GTR_EQ_ZERO);\n    const decoded = decodedMappings(map);\n    // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n    if (line >= decoded.length)\n        return OMapping(null, null, null, null);\n    const segments = decoded[line];\n    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n    if (index === -1)\n        return OMapping(null, null, null, null);\n    const segment = segments[index];\n    if (segment.length === 1)\n        return OMapping(null, null, null, null);\n    const { names, resolvedSources } = map;\n    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n}\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nfunction generatedPositionFor(map, needle) {\n    const { source, line, column, bias } = needle;\n    return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nfunction allGeneratedPositionsFor(map, needle) {\n    const { source, line, column, bias } = needle;\n    // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n    return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\n/**\n * Iterates each mapping in generated position order.\n */\nfunction eachMapping(map, cb) {\n    const decoded = decodedMappings(map);\n    const { names, resolvedSources } = map;\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            const generatedLine = i + 1;\n            const generatedColumn = seg[0];\n            let source = null;\n            let originalLine = null;\n            let originalColumn = null;\n            let name = null;\n            if (seg.length !== 1) {\n                source = resolvedSources[seg[1]];\n                originalLine = seg[2] + 1;\n                originalColumn = seg[3];\n            }\n            if (seg.length === 5)\n                name = names[seg[4]];\n            cb({\n                generatedLine,\n                generatedColumn,\n                source,\n                originalLine,\n                originalColumn,\n                name,\n            });\n        }\n    }\n}\nfunction sourceIndex(map, source) {\n    const { sources, resolvedSources } = map;\n    let index = sources.indexOf(source);\n    if (index === -1)\n        index = resolvedSources.indexOf(source);\n    return index;\n}\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nfunction sourceContentFor(map, source) {\n    const { sourcesContent } = map;\n    if (sourcesContent == null)\n        return null;\n    const index = sourceIndex(map, source);\n    return index === -1 ? null : sourcesContent[index];\n}\n/**\n * Determines if the source is marked to ignore by the source map.\n */\nfunction isIgnored(map, source) {\n    const { ignoreList } = map;\n    if (ignoreList == null)\n        return false;\n    const index = sourceIndex(map, source);\n    return index === -1 ? false : ignoreList.includes(index);\n}\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nfunction presortedDecodedMap(map, mapUrl) {\n    const tracer = new TraceMap(clone(map, []), mapUrl);\n    cast(tracer)._decoded = map.mappings;\n    return tracer;\n}\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nfunction decodedMap(map) {\n    return clone(map, decodedMappings(map));\n}\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nfunction encodedMap(map) {\n    return clone(map, encodedMappings(map));\n}\nfunction clone(map, mappings) {\n    return {\n        version: map.version,\n        file: map.file,\n        names: map.names,\n        sourceRoot: map.sourceRoot,\n        sources: map.sources,\n        sourcesContent: map.sourcesContent,\n        mappings,\n        ignoreList: map.ignoreList || map.x_google_ignoreList,\n    };\n}\nfunction OMapping(source, line, column, name) {\n    return { source, line, column, name };\n}\nfunction GMapping(line, column) {\n    return { line, column };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) {\n        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    }\n    else if (bias === LEAST_UPPER_BOUND)\n        index++;\n    if (index === -1 || index === segments.length)\n        return -1;\n    return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n    // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n    // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n    // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n    // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n    // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n    // match LEAST_UPPER_BOUND.\n    if (!found && bias === LEAST_UPPER_BOUND)\n        min++;\n    if (min === -1 || min === segments.length)\n        return [];\n    // We may have found the segment that started at an earlier column. If this is the case, then we\n    // need to slice all generated segments that match _that_ column, because all such segments span\n    // to our desired column.\n    const matchedColumn = found ? column : segments[min][COLUMN];\n    // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n    if (!found)\n        min = lowerBound(segments, matchedColumn, min);\n    const max = upperBound(segments, matchedColumn, min);\n    const result = [];\n    for (; min <= max; min++) {\n        const segment = segments[min];\n        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n    }\n    return result;\n}\nfunction generatedPosition(map, source, line, column, bias, all) {\n    var _a;\n    line--;\n    if (line < 0)\n        throw new Error(LINE_GTR_ZERO);\n    if (column < 0)\n        throw new Error(COL_GTR_EQ_ZERO);\n    const { sources, resolvedSources } = map;\n    let sourceIndex = sources.indexOf(source);\n    if (sourceIndex === -1)\n        sourceIndex = resolvedSources.indexOf(source);\n    if (sourceIndex === -1)\n        return all ? [] : GMapping(null, null);\n    const generated = ((_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), (cast(map)._bySourceMemos = sources.map(memoizedState)))));\n    const segments = generated[sourceIndex][line];\n    if (segments == null)\n        return all ? [] : GMapping(null, null);\n    const memo = cast(map)._bySourceMemos[sourceIndex];\n    if (all)\n        return sliceGeneratedPositions(segments, memo, line, column, bias);\n    const index = traceSegmentInternal(segments, memo, line, column, bias);\n    if (index === -1)\n        return GMapping(null, null);\n    const segment = segments[index];\n    return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\n\n\n//# sourceMappingURL=trace-mapping.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BqcmlkZ2V3ZWxsK3RyYWNlLW1hcHBpbmdAMC4zLjI1L25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC90cmFjZS1tYXBwaW5nL2Rpc3QvdHJhY2UtbWFwcGluZy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZEO0FBQ1o7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUVBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFp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ZXMvLnBucG0vQGpyaWRnZXdlbGwrdHJhY2UtbWFwcGluZ0AwLjMuMjUvbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmcvZGlzdC90cmFjZS1tYXBwaW5nLm1qcz9kODY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVuY29kZSwgZGVjb2RlIH0gZnJvbSAnQGpyaWRnZXdlbGwvc291cmNlbWFwLWNvZGVjJztcbmltcG9ydCByZXNvbHZlVXJpIGZyb20gJ0BqcmlkZ2V3ZWxsL3Jlc29sdmUtdXJpJztcblxuZnVuY3Rpb24gcmVzb2x2ZShpbnB1dCwgYmFzZSkge1xuICAgIC8vIFRoZSBiYXNlIGlzIGFsd2F5cyB0cmVhdGVkIGFzIGEgZGlyZWN0b3J5LCBpZiBpdCdzIG5vdCBlbXB0eS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2Jsb2IvOGNiM2VlNTcvbGliL3V0aWwuanMjTDMyN1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaHJvbWl1bS9jaHJvbWl1bS9ibG9iL2RhNGFkYmIzL3RoaXJkX3BhcnR5L2JsaW5rL3JlbmRlcmVyL2RldnRvb2xzL2Zyb250X2VuZC9zZGsvU291cmNlTWFwLmpzI0w0MDAtTDQwMVxuICAgIGlmIChiYXNlICYmICFiYXNlLmVuZHNXaXRoKCcvJykpXG4gICAgICAgIGJhc2UgKz0gJy8nO1xuICAgIHJldHVybiByZXNvbHZlVXJpKGlucHV0LCBiYXNlKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGxhc3QgXCIvXCIsIGJ1dCBsZWF2ZXMgdGhlIHNsYXNoLlxuICovXG5mdW5jdGlvbiBzdHJpcEZpbGVuYW1lKHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBpbmRleCArIDEpO1xufVxuXG5jb25zdCBDT0xVTU4gPSAwO1xuY29uc3QgU09VUkNFU19JTkRFWCA9IDE7XG5jb25zdCBTT1VSQ0VfTElORSA9IDI7XG5jb25zdCBTT1VSQ0VfQ09MVU1OID0gMztcbmNvbnN0IE5BTUVTX0lOREVYID0gNDtcbmNvbnN0IFJFVl9HRU5FUkFURURfTElORSA9IDE7XG5jb25zdCBSRVZfR0VORVJBVEVEX0NPTFVNTiA9IDI7XG5cbmZ1bmN0aW9uIG1heWJlU29ydChtYXBwaW5ncywgb3duZWQpIHtcbiAgICBjb25zdCB1bnNvcnRlZEluZGV4ID0gbmV4dFVuc29ydGVkU2VnbWVudExpbmUobWFwcGluZ3MsIDApO1xuICAgIGlmICh1bnNvcnRlZEluZGV4ID09PSBtYXBwaW5ncy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBtYXBwaW5ncztcbiAgICAvLyBJZiB3ZSBvd24gdGhlIGFycmF5IChtZWFuaW5nIHdlIHBhcnNlZCBpdCBmcm9tIEpTT04pLCB0aGVuIHdlJ3JlIGZyZWUgdG8gZGlyZWN0bHkgbXV0YXRlIGl0LiBJZlxuICAgIC8vIG5vdCwgd2UgZG8gbm90IHdhbnQgdG8gbW9kaWZ5IHRoZSBjb25zdW1lcidzIGlucHV0IGFycmF5LlxuICAgIGlmICghb3duZWQpXG4gICAgICAgIG1hcHBpbmdzID0gbWFwcGluZ3Muc2xpY2UoKTtcbiAgICBmb3IgKGxldCBpID0gdW5zb3J0ZWRJbmRleDsgaSA8IG1hcHBpbmdzLmxlbmd0aDsgaSA9IG5leHRVbnNvcnRlZFNlZ21lbnRMaW5lKG1hcHBpbmdzLCBpICsgMSkpIHtcbiAgICAgICAgbWFwcGluZ3NbaV0gPSBzb3J0U2VnbWVudHMobWFwcGluZ3NbaV0sIG93bmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcHBpbmdzO1xufVxuZnVuY3Rpb24gbmV4dFVuc29ydGVkU2VnbWVudExpbmUobWFwcGluZ3MsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbWFwcGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc1NvcnRlZChtYXBwaW5nc1tpXSkpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcHBpbmdzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGlzU29ydGVkKGxpbmUpIHtcbiAgICBmb3IgKGxldCBqID0gMTsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGxpbmVbal1bQ09MVU1OXSA8IGxpbmVbaiAtIDFdW0NPTFVNTl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNvcnRTZWdtZW50cyhsaW5lLCBvd25lZCkge1xuICAgIGlmICghb3duZWQpXG4gICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKCk7XG4gICAgcmV0dXJuIGxpbmUuc29ydChzb3J0Q29tcGFyYXRvcik7XG59XG5mdW5jdGlvbiBzb3J0Q29tcGFyYXRvcihhLCBiKSB7XG4gICAgcmV0dXJuIGFbQ09MVU1OXSAtIGJbQ09MVU1OXTtcbn1cblxubGV0IGZvdW5kID0gZmFsc2U7XG4vKipcbiAqIEEgYmluYXJ5IHNlYXJjaCBpbXBsZW1lbnRhdGlvbiB0aGF0IHJldHVybnMgdGhlIGluZGV4IGlmIGEgbWF0Y2ggaXMgZm91bmQuXG4gKiBJZiBubyBtYXRjaCBpcyBmb3VuZCwgdGhlbiB0aGUgbGVmdC1pbmRleCAodGhlIGluZGV4IGFzc29jaWF0ZWQgd2l0aCB0aGUgaXRlbSB0aGF0IGNvbWVzIGp1c3RcbiAqIGJlZm9yZSB0aGUgZGVzaXJlZCBpbmRleCkgaXMgcmV0dXJuZWQuIFRvIG1haW50YWluIHByb3BlciBzb3J0IG9yZGVyLCBhIHNwbGljZSB3b3VsZCBoYXBwZW4gYXRcbiAqIHRoZSBuZXh0IGluZGV4OlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBhcnJheSA9IFsxLCAzXTtcbiAqIGNvbnN0IG5lZWRsZSA9IDI7XG4gKiBjb25zdCBpbmRleCA9IGJpbmFyeVNlYXJjaChhcnJheSwgbmVlZGxlLCAoaXRlbSwgbmVlZGxlKSA9PiBpdGVtIC0gbmVlZGxlKTtcbiAqXG4gKiBhc3NlcnQuZXF1YWwoaW5kZXgsIDApO1xuICogYXJyYXkuc3BsaWNlKGluZGV4ICsgMSwgMCwgbmVlZGxlKTtcbiAqIGFzc2VydC5kZWVwRXF1YWwoYXJyYXksIFsxLCAyLCAzXSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGhheXN0YWNrLCBuZWVkbGUsIGxvdywgaGlnaCkge1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgICBjb25zdCBtaWQgPSBsb3cgKyAoKGhpZ2ggLSBsb3cpID4+IDEpO1xuICAgICAgICBjb25zdCBjbXAgPSBoYXlzdGFja1ttaWRdW0NPTFVNTl0gLSBuZWVkbGU7XG4gICAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3VuZCA9IGZhbHNlO1xuICAgIHJldHVybiBsb3cgLSAxO1xufVxuZnVuY3Rpb24gdXBwZXJCb3VuZChoYXlzdGFjaywgbmVlZGxlLCBpbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBpbmRleCArIDE7IGkgPCBoYXlzdGFjay5sZW5ndGg7IGluZGV4ID0gaSsrKSB7XG4gICAgICAgIGlmIChoYXlzdGFja1tpXVtDT0xVTU5dICE9PSBuZWVkbGUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gbG93ZXJCb3VuZChoYXlzdGFjaywgbmVlZGxlLCBpbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaW5kZXggPSBpLS0pIHtcbiAgICAgICAgaWYgKGhheXN0YWNrW2ldW0NPTFVNTl0gIT09IG5lZWRsZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBtZW1vaXplZFN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxhc3RLZXk6IC0xLFxuICAgICAgICBsYXN0TmVlZGxlOiAtMSxcbiAgICAgICAgbGFzdEluZGV4OiAtMSxcbiAgICB9O1xufVxuLyoqXG4gKiBUaGlzIG92ZXJseSBjb21wbGljYXRlZCBiZWFzdCBpcyBqdXN0IHRvIHJlY29yZCB0aGUgbGFzdCB0ZXN0ZWQgbGluZS9jb2x1bW4gYW5kIHRoZSByZXN1bHRpbmdcbiAqIGluZGV4LCBhbGxvd2luZyB1cyB0byBza2lwIGEgZmV3IHRlc3RzIGlmIG1hcHBpbmdzIGFyZSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVkQmluYXJ5U2VhcmNoKGhheXN0YWNrLCBuZWVkbGUsIHN0YXRlLCBrZXkpIHtcbiAgICBjb25zdCB7IGxhc3RLZXksIGxhc3ROZWVkbGUsIGxhc3RJbmRleCB9ID0gc3RhdGU7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBoYXlzdGFjay5sZW5ndGggLSAxO1xuICAgIGlmIChrZXkgPT09IGxhc3RLZXkpIHtcbiAgICAgICAgaWYgKG5lZWRsZSA9PT0gbGFzdE5lZWRsZSkge1xuICAgICAgICAgICAgZm91bmQgPSBsYXN0SW5kZXggIT09IC0xICYmIGhheXN0YWNrW2xhc3RJbmRleF1bQ09MVU1OXSA9PT0gbmVlZGxlO1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZGxlID49IGxhc3ROZWVkbGUpIHtcbiAgICAgICAgICAgIC8vIGxhc3RJbmRleCBtYXkgYmUgLTEgaWYgdGhlIHByZXZpb3VzIG5lZWRsZSB3YXMgbm90IGZvdW5kLlxuICAgICAgICAgICAgbG93ID0gbGFzdEluZGV4ID09PSAtMSA/IDAgOiBsYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRlLmxhc3RLZXkgPSBrZXk7XG4gICAgc3RhdGUubGFzdE5lZWRsZSA9IG5lZWRsZTtcbiAgICByZXR1cm4gKHN0YXRlLmxhc3RJbmRleCA9IGJpbmFyeVNlYXJjaChoYXlzdGFjaywgbmVlZGxlLCBsb3csIGhpZ2gpKTtcbn1cblxuLy8gUmVidWlsZHMgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcywgd2l0aCBtYXBwaW5ncyB0aGF0IGFyZSBvcmRlcmVkIGJ5IHNvdXJjZSBsaW5lL2NvbHVtbiBpbnN0ZWFkXG4vLyBvZiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4uXG5mdW5jdGlvbiBidWlsZEJ5U291cmNlcyhkZWNvZGVkLCBtZW1vcykge1xuICAgIGNvbnN0IHNvdXJjZXMgPSBtZW1vcy5tYXAoYnVpbGROdWxsQXJyYXkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsaW5lID0gZGVjb2RlZFtpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBzZWcgPSBsaW5lW2pdO1xuICAgICAgICAgICAgaWYgKHNlZy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VJbmRleCA9IHNlZ1tTT1VSQ0VTX0lOREVYXTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUxpbmUgPSBzZWdbU09VUkNFX0xJTkVdO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlQ29sdW1uID0gc2VnW1NPVVJDRV9DT0xVTU5dO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTb3VyY2UgPSBzb3VyY2VzW3NvdXJjZUluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZSA9IChvcmlnaW5hbFNvdXJjZVtzb3VyY2VMaW5lXSB8fCAob3JpZ2luYWxTb3VyY2Vbc291cmNlTGluZV0gPSBbXSkpO1xuICAgICAgICAgICAgY29uc3QgbWVtbyA9IG1lbW9zW3NvdXJjZUluZGV4XTtcbiAgICAgICAgICAgIC8vIFRoZSBiaW5hcnkgc2VhcmNoIGVpdGhlciBmb3VuZCBhIG1hdGNoLCBvciBpdCBmb3VuZCB0aGUgbGVmdC1pbmRleCBqdXN0IGJlZm9yZSB3aGVyZSB0aGVcbiAgICAgICAgICAgIC8vIHNlZ21lbnQgc2hvdWxkIGdvLiBFaXRoZXIgd2F5LCB3ZSB3YW50IHRvIGluc2VydCBhZnRlciB0aGF0LiBBbmQgdGhlcmUgbWF5IGJlIG11bHRpcGxlXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZWQgc2VnbWVudHMgYXNzb2NpYXRlZCB3aXRoIGFuIG9yaWdpbmFsIGxvY2F0aW9uLCBzbyB0aGVyZSBtYXkgbmVlZCB0byBtb3ZlIHNldmVyYWxcbiAgICAgICAgICAgIC8vIGluZGV4ZXMgYmVmb3JlIHdlIGZpbmQgd2hlcmUgd2UgbmVlZCB0byBpbnNlcnQuXG4gICAgICAgICAgICBsZXQgaW5kZXggPSB1cHBlckJvdW5kKG9yaWdpbmFsTGluZSwgc291cmNlQ29sdW1uLCBtZW1vaXplZEJpbmFyeVNlYXJjaChvcmlnaW5hbExpbmUsIHNvdXJjZUNvbHVtbiwgbWVtbywgc291cmNlTGluZSkpO1xuICAgICAgICAgICAgbWVtby5sYXN0SW5kZXggPSArK2luZGV4O1xuICAgICAgICAgICAgaW5zZXJ0KG9yaWdpbmFsTGluZSwgaW5kZXgsIFtzb3VyY2VDb2x1bW4sIGksIHNlZ1tDT0xVTU5dXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG59XG5mdW5jdGlvbiBpbnNlcnQoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGg7IGkgPiBpbmRleDsgaS0tKSB7XG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSAtIDFdO1xuICAgIH1cbiAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbn1cbi8vIE51bGwgYXJyYXlzIGFsbG93IHVzIHRvIHVzZSBvcmRlcmVkIGluZGV4IGtleXMgd2l0aG91dCBhY3R1YWxseSBhbGxvY2F0aW5nIGNvbnRpZ3VvdXMgbWVtb3J5IGxpa2Vcbi8vIGEgcmVhbCBhcnJheS4gV2UgdXNlIGEgbnVsbC1wcm90b3R5cGUgb2JqZWN0IHRvIGF2b2lkIHByb3RvdHlwZSBwb2xsdXRpb24gYW5kIGRlb3B0aW1pemF0aW9ucy5cbi8vIE51bWVyaWMgcHJvcGVydGllcyBvbiBvYmplY3RzIGFyZSBtYWdpY2FsbHkgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgZW5naW5lIHJlZ2FyZGxlc3Mgb2Zcbi8vIHRoZSBpbnNlcnRpb24gb3JkZXIuIFNvLCBieSBzZXR0aW5nIGFueSBudW1lcmljIGtleXMsIGV2ZW4gb3V0IG9mIG9yZGVyLCB3ZSdsbCBnZXQgYXNjZW5kaW5nXG4vLyBvcmRlciB3aGVuIGl0ZXJhdGluZyB3aXRoIGZvci1pbi5cbmZ1bmN0aW9uIGJ1aWxkTnVsbEFycmF5KCkge1xuICAgIHJldHVybiB7IF9fcHJvdG9fXzogbnVsbCB9O1xufVxuXG5jb25zdCBBbnlNYXAgPSBmdW5jdGlvbiAobWFwLCBtYXBVcmwpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZShtYXApO1xuICAgIGlmICghKCdzZWN0aW9ucycgaW4gcGFyc2VkKSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYWNlTWFwKHBhcnNlZCwgbWFwVXJsKTtcbiAgICB9XG4gICAgY29uc3QgbWFwcGluZ3MgPSBbXTtcbiAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgY29uc3Qgc291cmNlc0NvbnRlbnQgPSBbXTtcbiAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgIGNvbnN0IGlnbm9yZUxpc3QgPSBbXTtcbiAgICByZWN1cnNlKHBhcnNlZCwgbWFwVXJsLCBtYXBwaW5ncywgc291cmNlcywgc291cmNlc0NvbnRlbnQsIG5hbWVzLCBpZ25vcmVMaXN0LCAwLCAwLCBJbmZpbml0eSwgSW5maW5pdHkpO1xuICAgIGNvbnN0IGpvaW5lZCA9IHtcbiAgICAgICAgdmVyc2lvbjogMyxcbiAgICAgICAgZmlsZTogcGFyc2VkLmZpbGUsXG4gICAgICAgIG5hbWVzLFxuICAgICAgICBzb3VyY2VzLFxuICAgICAgICBzb3VyY2VzQ29udGVudCxcbiAgICAgICAgbWFwcGluZ3MsXG4gICAgICAgIGlnbm9yZUxpc3QsXG4gICAgfTtcbiAgICByZXR1cm4gcHJlc29ydGVkRGVjb2RlZE1hcChqb2luZWQpO1xufTtcbmZ1bmN0aW9uIHBhcnNlKG1hcCkge1xuICAgIHJldHVybiB0eXBlb2YgbWFwID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWFwKSA6IG1hcDtcbn1cbmZ1bmN0aW9uIHJlY3Vyc2UoaW5wdXQsIG1hcFVybCwgbWFwcGluZ3MsIHNvdXJjZXMsIHNvdXJjZXNDb250ZW50LCBuYW1lcywgaWdub3JlTGlzdCwgbGluZU9mZnNldCwgY29sdW1uT2Zmc2V0LCBzdG9wTGluZSwgc3RvcENvbHVtbikge1xuICAgIGNvbnN0IHsgc2VjdGlvbnMgfSA9IGlucHV0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBtYXAsIG9mZnNldCB9ID0gc2VjdGlvbnNbaV07XG4gICAgICAgIGxldCBzbCA9IHN0b3BMaW5lO1xuICAgICAgICBsZXQgc2MgPSBzdG9wQ29sdW1uO1xuICAgICAgICBpZiAoaSArIDEgPCBzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSBzZWN0aW9uc1tpICsgMV0ub2Zmc2V0O1xuICAgICAgICAgICAgc2wgPSBNYXRoLm1pbihzdG9wTGluZSwgbGluZU9mZnNldCArIG5leHRPZmZzZXQubGluZSk7XG4gICAgICAgICAgICBpZiAoc2wgPT09IHN0b3BMaW5lKSB7XG4gICAgICAgICAgICAgICAgc2MgPSBNYXRoLm1pbihzdG9wQ29sdW1uLCBjb2x1bW5PZmZzZXQgKyBuZXh0T2Zmc2V0LmNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzbCA8IHN0b3BMaW5lKSB7XG4gICAgICAgICAgICAgICAgc2MgPSBjb2x1bW5PZmZzZXQgKyBuZXh0T2Zmc2V0LmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRTZWN0aW9uKG1hcCwgbWFwVXJsLCBtYXBwaW5ncywgc291cmNlcywgc291cmNlc0NvbnRlbnQsIG5hbWVzLCBpZ25vcmVMaXN0LCBsaW5lT2Zmc2V0ICsgb2Zmc2V0LmxpbmUsIGNvbHVtbk9mZnNldCArIG9mZnNldC5jb2x1bW4sIHNsLCBzYyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkU2VjdGlvbihpbnB1dCwgbWFwVXJsLCBtYXBwaW5ncywgc291cmNlcywgc291cmNlc0NvbnRlbnQsIG5hbWVzLCBpZ25vcmVMaXN0LCBsaW5lT2Zmc2V0LCBjb2x1bW5PZmZzZXQsIHN0b3BMaW5lLCBzdG9wQ29sdW1uKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2UoaW5wdXQpO1xuICAgIGlmICgnc2VjdGlvbnMnIGluIHBhcnNlZClcbiAgICAgICAgcmV0dXJuIHJlY3Vyc2UoLi4uYXJndW1lbnRzKTtcbiAgICBjb25zdCBtYXAgPSBuZXcgVHJhY2VNYXAocGFyc2VkLCBtYXBVcmwpO1xuICAgIGNvbnN0IHNvdXJjZXNPZmZzZXQgPSBzb3VyY2VzLmxlbmd0aDtcbiAgICBjb25zdCBuYW1lc09mZnNldCA9IG5hbWVzLmxlbmd0aDtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlZE1hcHBpbmdzKG1hcCk7XG4gICAgY29uc3QgeyByZXNvbHZlZFNvdXJjZXMsIHNvdXJjZXNDb250ZW50OiBjb250ZW50cywgaWdub3JlTGlzdDogaWdub3JlcyB9ID0gbWFwO1xuICAgIGFwcGVuZChzb3VyY2VzLCByZXNvbHZlZFNvdXJjZXMpO1xuICAgIGFwcGVuZChuYW1lcywgbWFwLm5hbWVzKTtcbiAgICBpZiAoY29udGVudHMpXG4gICAgICAgIGFwcGVuZChzb3VyY2VzQ29udGVudCwgY29udGVudHMpO1xuICAgIGVsc2VcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZFNvdXJjZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzb3VyY2VzQ29udGVudC5wdXNoKG51bGwpO1xuICAgIGlmIChpZ25vcmVzKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlnbm9yZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZ25vcmVMaXN0LnB1c2goaWdub3Jlc1tpXSArIHNvdXJjZXNPZmZzZXQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsaW5lSSA9IGxpbmVPZmZzZXQgKyBpO1xuICAgICAgICAvLyBXZSBjYW4gb25seSBhZGQgc28gbWFueSBsaW5lcyBiZWZvcmUgd2Ugc3RlcCBpbnRvIHRoZSByYW5nZSB0aGF0IHRoZSBuZXh0IHNlY3Rpb24ncyBtYXBcbiAgICAgICAgLy8gY29udHJvbHMuIFdoZW4gd2UgZ2V0IHRvIHRoZSBsYXN0IGxpbmUsIHRoZW4gd2UnbGwgc3RhcnQgY2hlY2tpbmcgdGhlIHNlZ21lbnRzIHRvIHNlZSBpZlxuICAgICAgICAvLyB0aGV5J3ZlIGNyb3NzZWQgaW50byB0aGUgY29sdW1uIHJhbmdlLiBCdXQgaXQgbWF5IG5vdCBoYXZlIGFueSBjb2x1bW5zIHRoYXQgb3ZlcnN0ZXAsIHNvIHdlXG4gICAgICAgIC8vIHN0aWxsIG5lZWQgdG8gY2hlY2sgdGhhdCB3ZSBkb24ndCBvdmVyc3RlcCBsaW5lcywgdG9vLlxuICAgICAgICBpZiAobGluZUkgPiBzdG9wTGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVGhlIG91dCBsaW5lIG1heSBhbHJlYWR5IGV4aXN0IGluIG1hcHBpbmdzIChpZiB3ZSdyZSBjb250aW51aW5nIHRoZSBsaW5lIHN0YXJ0ZWQgYnkgYVxuICAgICAgICAvLyBwcmV2aW91cyBzZWN0aW9uKS4gT3IsIHdlIG1heSBoYXZlIGp1bXBlZCBhaGVhZCBzZXZlcmFsIGxpbmVzIHRvIHN0YXJ0IHRoaXMgc2VjdGlvbi5cbiAgICAgICAgY29uc3Qgb3V0ID0gZ2V0TGluZShtYXBwaW5ncywgbGluZUkpO1xuICAgICAgICAvLyBPbiB0aGUgMHRoIGxvb3AsIHRoZSBzZWN0aW9uJ3MgY29sdW1uIG9mZnNldCBzaGlmdHMgdXMgZm9yd2FyZC4gT24gYWxsIG90aGVyIGxpbmVzIChzaW5jZSB0aGVcbiAgICAgICAgLy8gbWFwIGNhbiBiZSBtdWx0aXBsZSBsaW5lcyksIGl0IGRvZXNuJ3QuXG4gICAgICAgIGNvbnN0IGNPZmZzZXQgPSBpID09PSAwID8gY29sdW1uT2Zmc2V0IDogMDtcbiAgICAgICAgY29uc3QgbGluZSA9IGRlY29kZWRbaV07XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc2VnID0gbGluZVtqXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGNPZmZzZXQgKyBzZWdbQ09MVU1OXTtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgc2VnbWVudCBzdGVwcyBpbnRvIHRoZSBjb2x1bW4gcmFuZ2UgdGhhdCB0aGUgbmV4dCBzZWN0aW9uJ3MgbWFwIGNvbnRyb2xzLCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyB0byBzdG9wIGVhcmx5LlxuICAgICAgICAgICAgaWYgKGxpbmVJID09PSBzdG9wTGluZSAmJiBjb2x1bW4gPj0gc3RvcENvbHVtbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoc2VnLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKFtjb2x1bW5dKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZXNJbmRleCA9IHNvdXJjZXNPZmZzZXQgKyBzZWdbU09VUkNFU19JTkRFWF07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VMaW5lID0gc2VnW1NPVVJDRV9MSU5FXTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUNvbHVtbiA9IHNlZ1tTT1VSQ0VfQ09MVU1OXTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNlZy5sZW5ndGggPT09IDRcbiAgICAgICAgICAgICAgICA/IFtjb2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uXVxuICAgICAgICAgICAgICAgIDogW2NvbHVtbiwgc291cmNlc0luZGV4LCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWVzT2Zmc2V0ICsgc2VnW05BTUVTX0lOREVYXV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kKGFyciwgb3RoZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVyLmxlbmd0aDsgaSsrKVxuICAgICAgICBhcnIucHVzaChvdGhlcltpXSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lKGFyciwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBpID0gYXJyLmxlbmd0aDsgaSA8PSBpbmRleDsgaSsrKVxuICAgICAgICBhcnJbaV0gPSBbXTtcbiAgICByZXR1cm4gYXJyW2luZGV4XTtcbn1cblxuY29uc3QgTElORV9HVFJfWkVSTyA9ICdgbGluZWAgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCAobGluZXMgc3RhcnQgYXQgbGluZSAxKSc7XG5jb25zdCBDT0xfR1RSX0VRX1pFUk8gPSAnYGNvbHVtbmAgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCAoY29sdW1ucyBzdGFydCBhdCBjb2x1bW4gMCknO1xuY29uc3QgTEVBU1RfVVBQRVJfQk9VTkQgPSAtMTtcbmNvbnN0IEdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbmNsYXNzIFRyYWNlTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihtYXAsIG1hcFVybCkge1xuICAgICAgICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBtYXAgPT09ICdzdHJpbmcnO1xuICAgICAgICBpZiAoIWlzU3RyaW5nICYmIG1hcC5fZGVjb2RlZE1lbW8pXG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSAoaXNTdHJpbmcgPyBKU09OLnBhcnNlKG1hcCkgOiBtYXApO1xuICAgICAgICBjb25zdCB7IHZlcnNpb24sIGZpbGUsIG5hbWVzLCBzb3VyY2VSb290LCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCB9ID0gcGFyc2VkO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB0aGlzLm5hbWVzID0gbmFtZXMgfHwgW107XG4gICAgICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IHNvdXJjZXM7XG4gICAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgICAgICAgdGhpcy5pZ25vcmVMaXN0ID0gcGFyc2VkLmlnbm9yZUxpc3QgfHwgcGFyc2VkLnhfZ29vZ2xlX2lnbm9yZUxpc3QgfHwgdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBmcm9tID0gcmVzb2x2ZShzb3VyY2VSb290IHx8ICcnLCBzdHJpcEZpbGVuYW1lKG1hcFVybCkpO1xuICAgICAgICB0aGlzLnJlc29sdmVkU291cmNlcyA9IHNvdXJjZXMubWFwKChzKSA9PiByZXNvbHZlKHMgfHwgJycsIGZyb20pKTtcbiAgICAgICAgY29uc3QgeyBtYXBwaW5ncyB9ID0gcGFyc2VkO1xuICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fZW5jb2RlZCA9IG1hcHBpbmdzO1xuICAgICAgICAgICAgdGhpcy5fZGVjb2RlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9kZWNvZGVkID0gbWF5YmVTb3J0KG1hcHBpbmdzLCBpc1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVjb2RlZE1lbW8gPSBtZW1vaXplZFN0YXRlKCk7XG4gICAgICAgIHRoaXMuX2J5U291cmNlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fYnlTb3VyY2VNZW1vcyA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKipcbiAqIFR5cGVzY3JpcHQgZG9lc24ndCBhbGxvdyBmcmllbmQgYWNjZXNzIHRvIHByaXZhdGUgZmllbGRzLCBzbyB0aGlzIGp1c3QgY2FzdHMgdGhlIG1hcCBpbnRvIGEgdHlwZVxuICogd2l0aCBwdWJsaWMgYWNjZXNzIG1vZGlmaWVycy5cbiAqL1xuZnVuY3Rpb24gY2FzdChtYXApIHtcbiAgICByZXR1cm4gbWFwO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbmNvZGVkIChWTFEgc3RyaW5nKSBmb3JtIG9mIHRoZSBTb3VyY2VNYXAncyBtYXBwaW5ncyBmaWVsZC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlZE1hcHBpbmdzKG1hcCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgX2I7XG4gICAgcmV0dXJuICgoX2EgPSAoX2IgPSBjYXN0KG1hcCkpLl9lbmNvZGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IuX2VuY29kZWQgPSBlbmNvZGUoY2FzdChtYXApLl9kZWNvZGVkKSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWNvZGVkIChhcnJheSBvZiBsaW5lcyBvZiBzZWdtZW50cykgZm9ybSBvZiB0aGUgU291cmNlTWFwJ3MgbWFwcGluZ3MgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZWRNYXBwaW5ncyhtYXApIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBjYXN0KG1hcCkpLl9kZWNvZGVkIHx8IChfYS5fZGVjb2RlZCA9IGRlY29kZShjYXN0KG1hcCkuX2VuY29kZWQpKSk7XG59XG4vKipcbiAqIEEgbG93LWxldmVsIEFQSSB0byBmaW5kIHRoZSBzZWdtZW50IGFzc29jaWF0ZWQgd2l0aCBhIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiAodGhpbmssIGZyb20gYVxuICogc3RhY2sgdHJhY2UpLiBMaW5lIGFuZCBjb2x1bW4gaGVyZSBhcmUgMC1iYXNlZCwgdW5saWtlIGBvcmlnaW5hbFBvc2l0aW9uRm9yYC5cbiAqL1xuZnVuY3Rpb24gdHJhY2VTZWdtZW50KG1hcCwgbGluZSwgY29sdW1uKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZWRNYXBwaW5ncyhtYXApO1xuICAgIC8vIEl0J3MgY29tbW9uIGZvciBwYXJlbnQgc291cmNlIG1hcHMgdG8gaGF2ZSBwb2ludGVycyB0byBsaW5lcyB0aGF0IGhhdmUgbm9cbiAgICAvLyBtYXBwaW5nIChsaWtlIGEgXCIvLyMgc291cmNlTWFwcGluZ1VSTD1cIikgYXQgdGhlIGVuZCBvZiB0aGUgY2hpbGQgZmlsZS5cbiAgICBpZiAobGluZSA+PSBkZWNvZGVkLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBkZWNvZGVkW2xpbmVdO1xuICAgIGNvbnN0IGluZGV4ID0gdHJhY2VTZWdtZW50SW50ZXJuYWwoc2VnbWVudHMsIGNhc3QobWFwKS5fZGVjb2RlZE1lbW8sIGxpbmUsIGNvbHVtbiwgR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyBudWxsIDogc2VnbWVudHNbaW5kZXhdO1xufVxuLyoqXG4gKiBBIGhpZ2hlci1sZXZlbCBBUEkgdG8gZmluZCB0aGUgc291cmNlL2xpbmUvY29sdW1uIGFzc29jaWF0ZWQgd2l0aCBhIGdlbmVyYXRlZCBsaW5lL2NvbHVtblxuICogKHRoaW5rLCBmcm9tIGEgc3RhY2sgdHJhY2UpLiBMaW5lIGlzIDEtYmFzZWQsIGJ1dCBjb2x1bW4gaXMgMC1iYXNlZCwgZHVlIHRvIGxlZ2FjeSBiZWhhdmlvciBpblxuICogYHNvdXJjZS1tYXBgIGxpYnJhcnkuXG4gKi9cbmZ1bmN0aW9uIG9yaWdpbmFsUG9zaXRpb25Gb3IobWFwLCBuZWVkbGUpIHtcbiAgICBsZXQgeyBsaW5lLCBjb2x1bW4sIGJpYXMgfSA9IG5lZWRsZTtcbiAgICBsaW5lLS07XG4gICAgaWYgKGxpbmUgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTElORV9HVFJfWkVSTyk7XG4gICAgaWYgKGNvbHVtbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihDT0xfR1RSX0VRX1pFUk8pO1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVkTWFwcGluZ3MobWFwKTtcbiAgICAvLyBJdCdzIGNvbW1vbiBmb3IgcGFyZW50IHNvdXJjZSBtYXBzIHRvIGhhdmUgcG9pbnRlcnMgdG8gbGluZXMgdGhhdCBoYXZlIG5vXG4gICAgLy8gbWFwcGluZyAobGlrZSBhIFwiLy8jIHNvdXJjZU1hcHBpbmdVUkw9XCIpIGF0IHRoZSBlbmQgb2YgdGhlIGNoaWxkIGZpbGUuXG4gICAgaWYgKGxpbmUgPj0gZGVjb2RlZC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBPTWFwcGluZyhudWxsLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICBjb25zdCBzZWdtZW50cyA9IGRlY29kZWRbbGluZV07XG4gICAgY29uc3QgaW5kZXggPSB0cmFjZVNlZ21lbnRJbnRlcm5hbChzZWdtZW50cywgY2FzdChtYXApLl9kZWNvZGVkTWVtbywgbGluZSwgY29sdW1uLCBiaWFzIHx8IEdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICByZXR1cm4gT01hcHBpbmcobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBPTWFwcGluZyhudWxsLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICBjb25zdCB7IG5hbWVzLCByZXNvbHZlZFNvdXJjZXMgfSA9IG1hcDtcbiAgICByZXR1cm4gT01hcHBpbmcocmVzb2x2ZWRTb3VyY2VzW3NlZ21lbnRbU09VUkNFU19JTkRFWF1dLCBzZWdtZW50W1NPVVJDRV9MSU5FXSArIDEsIHNlZ21lbnRbU09VUkNFX0NPTFVNTl0sIHNlZ21lbnQubGVuZ3RoID09PSA1ID8gbmFtZXNbc2VnbWVudFtOQU1FU19JTkRFWF1dIDogbnVsbCk7XG59XG4vKipcbiAqIEZpbmRzIHRoZSBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIHNvdXJjZS9saW5lL2NvbHVtbiBzb3VyY2UgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uRm9yKG1hcCwgbmVlZGxlKSB7XG4gICAgY29uc3QgeyBzb3VyY2UsIGxpbmUsIGNvbHVtbiwgYmlhcyB9ID0gbmVlZGxlO1xuICAgIHJldHVybiBnZW5lcmF0ZWRQb3NpdGlvbihtYXAsIHNvdXJjZSwgbGluZSwgY29sdW1uLCBiaWFzIHx8IEdSRUFURVNUX0xPV0VSX0JPVU5ELCBmYWxzZSk7XG59XG4vKipcbiAqIEZpbmRzIGFsbCBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gcG9zaXRpb25zIG9mIHRoZSBwcm92aWRlZCBzb3VyY2UvbGluZS9jb2x1bW4gc291cmNlIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBhbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IobWFwLCBuZWVkbGUpIHtcbiAgICBjb25zdCB7IHNvdXJjZSwgbGluZSwgY29sdW1uLCBiaWFzIH0gPSBuZWVkbGU7XG4gICAgLy8gU291cmNlTWFwQ29uc3VtZXIgdXNlcyBMRUFTVF9VUFBFUl9CT1VORCBmb3Igc29tZSByZWFzb24sIHNvIHdlIGZvbGxvdyBzdWl0LlxuICAgIHJldHVybiBnZW5lcmF0ZWRQb3NpdGlvbihtYXAsIHNvdXJjZSwgbGluZSwgY29sdW1uLCBiaWFzIHx8IExFQVNUX1VQUEVSX0JPVU5ELCB0cnVlKTtcbn1cbi8qKlxuICogSXRlcmF0ZXMgZWFjaCBtYXBwaW5nIGluIGdlbmVyYXRlZCBwb3NpdGlvbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gZWFjaE1hcHBpbmcobWFwLCBjYikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVkTWFwcGluZ3MobWFwKTtcbiAgICBjb25zdCB7IG5hbWVzLCByZXNvbHZlZFNvdXJjZXMgfSA9IG1hcDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IGRlY29kZWRbaV07XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc2VnID0gbGluZVtqXTtcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZExpbmUgPSBpICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZENvbHVtbiA9IHNlZ1swXTtcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsTGluZSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHNlZy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSByZXNvbHZlZFNvdXJjZXNbc2VnWzFdXTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbExpbmUgPSBzZWdbMl0gKyAxO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29sdW1uID0gc2VnWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZy5sZW5ndGggPT09IDUpXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVzW3NlZ1s0XV07XG4gICAgICAgICAgICBjYih7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzb3VyY2VJbmRleChtYXAsIHNvdXJjZSkge1xuICAgIGNvbnN0IHsgc291cmNlcywgcmVzb2x2ZWRTb3VyY2VzIH0gPSBtYXA7XG4gICAgbGV0IGluZGV4ID0gc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgaW5kZXggPSByZXNvbHZlZFNvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuICAgIHJldHVybiBpbmRleDtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBwYXJ0aWN1bGFyIHNvdXJjZSwgaWYgaXRzIGZvdW5kLiBSZXR1cm5zIG51bGwgaWYgbm90LlxuICovXG5mdW5jdGlvbiBzb3VyY2VDb250ZW50Rm9yKG1hcCwgc291cmNlKSB7XG4gICAgY29uc3QgeyBzb3VyY2VzQ29udGVudCB9ID0gbWFwO1xuICAgIGlmIChzb3VyY2VzQ29udGVudCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpbmRleCA9IHNvdXJjZUluZGV4KG1hcCwgc291cmNlKTtcbiAgICByZXR1cm4gaW5kZXggPT09IC0xID8gbnVsbCA6IHNvdXJjZXNDb250ZW50W2luZGV4XTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgc291cmNlIGlzIG1hcmtlZCB0byBpZ25vcmUgYnkgdGhlIHNvdXJjZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIGlzSWdub3JlZChtYXAsIHNvdXJjZSkge1xuICAgIGNvbnN0IHsgaWdub3JlTGlzdCB9ID0gbWFwO1xuICAgIGlmIChpZ25vcmVMaXN0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpbmRleCA9IHNvdXJjZUluZGV4KG1hcCwgc291cmNlKTtcbiAgICByZXR1cm4gaW5kZXggPT09IC0xID8gZmFsc2UgOiBpZ25vcmVMaXN0LmluY2x1ZGVzKGluZGV4KTtcbn1cbi8qKlxuICogQSBoZWxwZXIgdGhhdCBza2lwcyBzb3J0aW5nIG9mIHRoZSBpbnB1dCBtYXAncyBtYXBwaW5ncyBhcnJheSwgd2hpY2ggY2FuIGJlIGV4cGVuc2l2ZSBmb3IgbGFyZ2VyXG4gKiBtYXBzLlxuICovXG5mdW5jdGlvbiBwcmVzb3J0ZWREZWNvZGVkTWFwKG1hcCwgbWFwVXJsKSB7XG4gICAgY29uc3QgdHJhY2VyID0gbmV3IFRyYWNlTWFwKGNsb25lKG1hcCwgW10pLCBtYXBVcmwpO1xuICAgIGNhc3QodHJhY2VyKS5fZGVjb2RlZCA9IG1hcC5tYXBwaW5ncztcbiAgICByZXR1cm4gdHJhY2VyO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc291cmNlbWFwIG9iamVjdCAod2l0aCBkZWNvZGVkIG1hcHBpbmdzKSBzdWl0YWJsZSBmb3IgcGFzc2luZyB0byBhIGxpYnJhcnkgdGhhdCBleHBlY3RzXG4gKiBhIHNvdXJjZW1hcCwgb3IgdG8gSlNPTi5zdHJpbmdpZnkuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZWRNYXAobWFwKSB7XG4gICAgcmV0dXJuIGNsb25lKG1hcCwgZGVjb2RlZE1hcHBpbmdzKG1hcCkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc291cmNlbWFwIG9iamVjdCAod2l0aCBlbmNvZGVkIG1hcHBpbmdzKSBzdWl0YWJsZSBmb3IgcGFzc2luZyB0byBhIGxpYnJhcnkgdGhhdCBleHBlY3RzXG4gKiBhIHNvdXJjZW1hcCwgb3IgdG8gSlNPTi5zdHJpbmdpZnkuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZWRNYXAobWFwKSB7XG4gICAgcmV0dXJuIGNsb25lKG1hcCwgZW5jb2RlZE1hcHBpbmdzKG1hcCkpO1xufVxuZnVuY3Rpb24gY2xvbmUobWFwLCBtYXBwaW5ncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IG1hcC52ZXJzaW9uLFxuICAgICAgICBmaWxlOiBtYXAuZmlsZSxcbiAgICAgICAgbmFtZXM6IG1hcC5uYW1lcyxcbiAgICAgICAgc291cmNlUm9vdDogbWFwLnNvdXJjZVJvb3QsXG4gICAgICAgIHNvdXJjZXM6IG1hcC5zb3VyY2VzLFxuICAgICAgICBzb3VyY2VzQ29udGVudDogbWFwLnNvdXJjZXNDb250ZW50LFxuICAgICAgICBtYXBwaW5ncyxcbiAgICAgICAgaWdub3JlTGlzdDogbWFwLmlnbm9yZUxpc3QgfHwgbWFwLnhfZ29vZ2xlX2lnbm9yZUxpc3QsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIE9NYXBwaW5nKHNvdXJjZSwgbGluZSwgY29sdW1uLCBuYW1lKSB7XG4gICAgcmV0dXJuIHsgc291cmNlLCBsaW5lLCBjb2x1bW4sIG5hbWUgfTtcbn1cbmZ1bmN0aW9uIEdNYXBwaW5nKGxpbmUsIGNvbHVtbikge1xuICAgIHJldHVybiB7IGxpbmUsIGNvbHVtbiB9O1xufVxuZnVuY3Rpb24gdHJhY2VTZWdtZW50SW50ZXJuYWwoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgYmlhcykge1xuICAgIGxldCBpbmRleCA9IG1lbW9pemVkQmluYXJ5U2VhcmNoKHNlZ21lbnRzLCBjb2x1bW4sIG1lbW8sIGxpbmUpO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgICBpbmRleCA9IChiaWFzID09PSBMRUFTVF9VUFBFUl9CT1VORCA/IHVwcGVyQm91bmQgOiBsb3dlckJvdW5kKShzZWdtZW50cywgY29sdW1uLCBpbmRleCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpYXMgPT09IExFQVNUX1VQUEVSX0JPVU5EKVxuICAgICAgICBpbmRleCsrO1xuICAgIGlmIChpbmRleCA9PT0gLTEgfHwgaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNsaWNlR2VuZXJhdGVkUG9zaXRpb25zKHNlZ21lbnRzLCBtZW1vLCBsaW5lLCBjb2x1bW4sIGJpYXMpIHtcbiAgICBsZXQgbWluID0gdHJhY2VTZWdtZW50SW50ZXJuYWwoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICAgIC8vIFdlIGlnbm9yZWQgdGhlIGJpYXMgd2hlbiB0cmFjaW5nIHRoZSBzZWdtZW50IHNvIHRoYXQgd2UncmUgZ3Vhcm5hdGVlZCB0byBmaW5kIHRoZSBmaXJzdCAoaW5cbiAgICAvLyBpbnNlcnRpb24gb3JkZXIpIHNlZ21lbnQgdGhhdCBtYXRjaGVkLiBFdmVuIGlmIHdlIGRpZCByZXNwZWN0IHRoZSBiaWFzIHdoZW4gdHJhY2luZywgd2Ugd291bGRcbiAgICAvLyBzdGlsbCBuZWVkIHRvIGNhbGwgYGxvd2VyQm91bmQoKWAgdG8gZmluZCB0aGUgZmlyc3Qgc2VnbWVudCwgd2hpY2ggaXMgc2xvd2VyIHRoYW4ganVzdCBsb29raW5nXG4gICAgLy8gZm9yIHRoZSBHUkVBVEVTVF9MT1dFUl9CT1VORCB0byBiZWdpbiB3aXRoLiBUaGUgb25seSBkaWZmZXJlbmNlIHRoYXQgbWF0dGVycyBmb3IgdXMgaXMgd2hlbiB0aGVcbiAgICAvLyBiaW5hcnkgc2VhcmNoIGRpZG4ndCBtYXRjaCwgaW4gd2hpY2ggY2FzZSBHUkVBVEVTVF9MT1dFUl9CT1VORCBqdXN0IG5lZWRzIHRvIGluY3JlbWVudCB0b1xuICAgIC8vIG1hdGNoIExFQVNUX1VQUEVSX0JPVU5ELlxuICAgIGlmICghZm91bmQgJiYgYmlhcyA9PT0gTEVBU1RfVVBQRVJfQk9VTkQpXG4gICAgICAgIG1pbisrO1xuICAgIGlmIChtaW4gPT09IC0xIHx8IG1pbiA9PT0gc2VnbWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgLy8gV2UgbWF5IGhhdmUgZm91bmQgdGhlIHNlZ21lbnQgdGhhdCBzdGFydGVkIGF0IGFuIGVhcmxpZXIgY29sdW1uLiBJZiB0aGlzIGlzIHRoZSBjYXNlLCB0aGVuIHdlXG4gICAgLy8gbmVlZCB0byBzbGljZSBhbGwgZ2VuZXJhdGVkIHNlZ21lbnRzIHRoYXQgbWF0Y2ggX3RoYXRfIGNvbHVtbiwgYmVjYXVzZSBhbGwgc3VjaCBzZWdtZW50cyBzcGFuXG4gICAgLy8gdG8gb3VyIGRlc2lyZWQgY29sdW1uLlxuICAgIGNvbnN0IG1hdGNoZWRDb2x1bW4gPSBmb3VuZCA/IGNvbHVtbiA6IHNlZ21lbnRzW21pbl1bQ09MVU1OXTtcbiAgICAvLyBUaGUgYmluYXJ5IHNlYXJjaCBpcyBub3QgZ3VhcmFudGVlZCB0byBmaW5kIHRoZSBsb3dlciBib3VuZCB3aGVuIGEgbWF0Y2ggd2Fzbid0IGZvdW5kLlxuICAgIGlmICghZm91bmQpXG4gICAgICAgIG1pbiA9IGxvd2VyQm91bmQoc2VnbWVudHMsIG1hdGNoZWRDb2x1bW4sIG1pbik7XG4gICAgY29uc3QgbWF4ID0gdXBwZXJCb3VuZChzZWdtZW50cywgbWF0Y2hlZENvbHVtbiwgbWluKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKDsgbWluIDw9IG1heDsgbWluKyspIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW21pbl07XG4gICAgICAgIHJlc3VsdC5wdXNoKEdNYXBwaW5nKHNlZ21lbnRbUkVWX0dFTkVSQVRFRF9MSU5FXSArIDEsIHNlZ21lbnRbUkVWX0dFTkVSQVRFRF9DT0xVTU5dKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbihtYXAsIHNvdXJjZSwgbGluZSwgY29sdW1uLCBiaWFzLCBhbGwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGluZS0tO1xuICAgIGlmIChsaW5lIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKExJTkVfR1RSX1pFUk8pO1xuICAgIGlmIChjb2x1bW4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09MX0dUUl9FUV9aRVJPKTtcbiAgICBjb25zdCB7IHNvdXJjZXMsIHJlc29sdmVkU291cmNlcyB9ID0gbWFwO1xuICAgIGxldCBzb3VyY2VJbmRleCA9IHNvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuICAgIGlmIChzb3VyY2VJbmRleCA9PT0gLTEpXG4gICAgICAgIHNvdXJjZUluZGV4ID0gcmVzb2x2ZWRTb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcbiAgICBpZiAoc291cmNlSW5kZXggPT09IC0xKVxuICAgICAgICByZXR1cm4gYWxsID8gW10gOiBHTWFwcGluZyhudWxsLCBudWxsKTtcbiAgICBjb25zdCBnZW5lcmF0ZWQgPSAoKF9hID0gY2FzdChtYXApKS5fYnlTb3VyY2VzIHx8IChfYS5fYnlTb3VyY2VzID0gYnVpbGRCeVNvdXJjZXMoZGVjb2RlZE1hcHBpbmdzKG1hcCksIChjYXN0KG1hcCkuX2J5U291cmNlTWVtb3MgPSBzb3VyY2VzLm1hcChtZW1vaXplZFN0YXRlKSkpKSk7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBnZW5lcmF0ZWRbc291cmNlSW5kZXhdW2xpbmVdO1xuICAgIGlmIChzZWdtZW50cyA9PSBudWxsKVxuICAgICAgICByZXR1cm4gYWxsID8gW10gOiBHTWFwcGluZyhudWxsLCBudWxsKTtcbiAgICBjb25zdCBtZW1vID0gY2FzdChtYXApLl9ieVNvdXJjZU1lbW9zW3NvdXJjZUluZGV4XTtcbiAgICBpZiAoYWxsKVxuICAgICAgICByZXR1cm4gc2xpY2VHZW5lcmF0ZWRQb3NpdGlvbnMoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgYmlhcyk7XG4gICAgY29uc3QgaW5kZXggPSB0cmFjZVNlZ21lbnRJbnRlcm5hbChzZWdtZW50cywgbWVtbywgbGluZSwgY29sdW1uLCBiaWFzKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICByZXR1cm4gR01hcHBpbmcobnVsbCwgbnVsbCk7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgICByZXR1cm4gR01hcHBpbmcoc2VnbWVudFtSRVZfR0VORVJBVEVEX0xJTkVdICsgMSwgc2VnbWVudFtSRVZfR0VORVJBVEVEX0NPTFVNTl0pO1xufVxuXG5leHBvcnQgeyBBbnlNYXAsIEdSRUFURVNUX0xPV0VSX0JPVU5ELCBMRUFTVF9VUFBFUl9CT1VORCwgVHJhY2VNYXAsIGFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciwgZGVjb2RlZE1hcCwgZGVjb2RlZE1hcHBpbmdzLCBlYWNoTWFwcGluZywgZW5jb2RlZE1hcCwgZW5jb2RlZE1hcHBpbmdzLCBnZW5lcmF0ZWRQb3NpdGlvbkZvciwgaXNJZ25vcmVkLCBvcmlnaW5hbFBvc2l0aW9uRm9yLCBwcmVzb3J0ZWREZWNvZGVkTWFwLCBzb3VyY2VDb250ZW50Rm9yLCB0cmFjZVNlZ21lbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNlLW1hcHBpbmcubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs\n");

/***/ })

};
;